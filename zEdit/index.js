registerPatcher({
    info: info,
    gameModes: [xelib.gmTES5, xelib.gmSSE],
    settings: {
        label: 'Poverty Patcher',
        templateUrl: `${patcherUrl}/partials/settings.html`,
        defaultSettings: {
			patchFileName: 'PovertyPatch.esp',
      		processREFR: true,
      		processCONT: true,
      		processFLORandTREE: true,
      		processLVLI: true,
      		processNPC_: true,
			logCurrent: true
        }
    },
    requiredFiles: ["Poverty.esp"],
	getFilesToPatch: function (filenames) {
		return filenames.filter(function(value, index, arr) {
            return (value != "Poverty.esp");
        });
    },
    execute: (patchFile, helpers, settings, locals) => ({
        initialize: function () {
			xelib.SetFileAuthor(patchFile, "evrymetul and Elscrux");
			xelib.SetFileDescription(patchFile, "All-in-One Patch for Poverty by evrymetul - Automatically generated by zEdit-Patcher by Elscrux");
			xelib.BuildReferences(0, true);
			
			locals.blacklist = [
					"DefaultBookShelfBookMarker",
					"AleWhiterunQuest",
					"ArmorBoneCrown",
					"ArmorDragonPriestMaskWoodHelmet",
					"BasketCarry",
					"BYOHHouseGuide",
					"C04HagravenHead",
					"CasSecEntranceCrest",
					"CivilWarMapFlag01",
					"CR12TotemsOfHircine",
					"CWArrow",
					"CWDummy",
					"CWFort",
					"DA01",
					"DA03RuefulAxe",
					"DA04",
					"DA06Volendrung",
					"DA07",
					"DA08EbonyBlade",
					"DA13Afflicted",
					"DA14SamNote",
					"DA14SanguineRose",
					"DA14Water",
					"DA16SkullofCorruption",
					"DA16Torpor",
					"DancersFlute",
					"DB003TovaLetter",
					"DB01AventusLetter",
					"DB05ElvenBow",
					"DB06Schedule",
					"DB07Journal",
					"DBArmorGlovesReward",
					"DBBladeOfWoeReward",
					"DBCiceroJournal",
					"DLC01DrawKnife",
					"DLC01DweSchematics",
					"DLC1ElderScrollBack",
					"DLC01SoulCairnReaperFragment",
					"DLC01TortureTool01",
					"DLC1BoneHawk",
					"DLC1Book3Valuable",
					"DLC1DarkfallPassageNote",
					"DLC1DawnguardRune",
					"DLC1dunRedwaterDenJournal",
					"DLC1FVBook02English",
					"DLC1IvoryCrown",
					"DLC1LD_Aetheri",
					"DLC1LD_Katria",
					"DLC1nVampireNightPowerNecklaceBats",
					"DLC1RecipeFrenzy1",
					"DLC1RuunvaldJournal",
					"DLC1SoulCairnRJPOI2Note",
					"DLC1SpellTomeConjure",
					"DLC1VQ07InitiatesEwer",
					"DLC1V",
					"DLC2Bl",
					"DLC2dunBloodskalNote01",
					"DLC2dunFahlbtharzDwarvenHelmet",
					"DLC2dunHaknirScimitar01",
					"DLC2dunKarstaagSkullItemNoName",
					"DLC2dunKolbjornBoots",
					"DLC2dunKolbjornGauntlets",
					"DLC2dunKolbjornHelm",
					"DLC2dunKolbjornMinersNote",
					"DLC2dunKolbjornSkull",
					"DLC2dunKolbjornRalisJournal",
					"DLC2dunKolbjornRing",
					"DLC2dunNchardakCube",
					"DLC2DweKagrumezControlGemInv01",
					"DLC2ExpSpiderExperimentJournal",
					"DLC2FrostmothLetter04",
					"DLC2Hork",
					"DLC2Hrodulf",
					"DLC2IldariJournal",
					"DLC2KagrumezFateBow01",
					"dlc2MerchNote",
					"DLC2POIUshaNote01",
					"DLC2RR",
					"DLC2TG",
					"DLC2TT2HeartStone",
					"Dummy",
					"dunAbandonedPrisonNote",
					"dunAlftandDwemerStudy01",
					"dunAlftandEndrastsJournal01",
					"dunAlftandJ",
					"dunAlftandManifestJournal01",
					"dunAn",
					"dunBloatedMan",
					"dunBrokenOarHargarJournal",
					"dunC",
					"dunD",
					"dunEmbershardTatteredJournal",
					"dunF",
					"dunG",
					"dunHa",
					"dunHuntersBow",
					"dunIlinaltasDeepAdventurerJournal",
					"dunIronbindLetter",
					"dunK",
					"dunLabyrinthian",
					"DunLabyrinthianSpellTomeEquilibrium",
					"dunLiarsRetreatLonghammer",
					"dunLost",
					"dunMarkarthWizard_LabJournal",
					"dunMarkarthWizardSpiderControlStaff",
					"dunMidden",
					"dunMistwatch",
					"dunMovarthsBoots",
					"dunMzinchaleft",
					"dunN",
					"dunOrotheimJournal",
					"dunP",
					"DunP",
					"DUNPOIDragonAttackNote",
					"dunR",
					"dunSaarthalStaffJyrikStaff",
					"dunSerpentsBluffNote",
					"dunShipwreck04TriusNote",
					"dunSilentMoonsLunarBook",
					"dunSteamcragCampNote",
					"dunT",
					"dunU",
					"dunV",
					"dunW",
					"dunYng",
					"DunYngolBarrowSteelPlateHelmet",
					"EnchArmorDraugrHelmetResistFire03",
					"EnchCircletWaterbreathing",
					"EnchDraugrGreatswordHonedFire03",
					"EnchSteelBattleaxeFierySouls",
					"Favor",
					"FF",
					"FirebrandWine",
					"Freeform",
					"FXdustDropMedWEP",
					"highGateRuinsScroll",
					"ImperialWarHorn",
					"IronSwordBrokenHandle",
					"IronWarAxeBroken",
					"Letter",
					"Markarth",
					"MG03Book",
					"MGRArniel04SoulGem",
					"MGRDestruction",
					"MGRitual02Book",
					"MGRKeening",
					"MQ103FarengarBook",
					"MQ105Note",
					"MQ106DragonParchment",
					"MQPaarthurnaxBook",
					"MS",
					"NN01SinderionsJournal",
					"POI",
					"sc_ArvakSkullUNIQUE",
					"SolitudeToryggWarHorn",
					"SpellTomeTransmuteOreMineral",
					"SovRoastOx",
					"SteelBattleAxeBroken",
					"T0",
					"TG00MadesiRing",
					"TG01HaelgaStatue",
					"TG02BillofSale",
					"TG03SabjornLetter",
					"TG04",
					"TG05GallusJournalPre",
					"TG07Chillrend001",
					"TG07MercersPlans",
					"TG08SkeletonKey",
					"TGBook0NightingalesVolume",
					"TGCrown",
					"TGFenceCaravanSatchel",
					"TGLT",
					"TGTQ",
					"TGRFOValueItem",
					"TGRGeneralValueItem",
					"TGTQ03SolitudeLetter",
					"TrapDweBallistaBoltAmmo01",
					"Windhelm",
					"YsgramorsBladePiece07"
			]
			
			locals.blacklistCONT = [
				"DEMO",
				"DLC01QA",
				"DLC02QA",
				"DLC2dunFrostmoonVendorChest",
				"DLC2MaximianPack",
				"e3DEMO",
				"E3Demo",
				"MQ101BarracksChest02",
				"MQ201ElenwenOfficeChest",
				"QA",
				"SkyHavenArmoryChest"
			]
			
			locals.blacklistFLOR = [
				"CoinPurse",
				"BYOHMead",
				"TGCoinPurse"
			]
			
			locals.blacklistLVLI = [
					"ArmorCompanionsSet",
					"ArmorElvenSet",
					"ArmorGlassSet",
					"ArmorHideSet",
					"ArmorImperialHeavyHelmets",
					"ArmorImperialHeavySet",
					"ArmorImperialLightSet",
					"ArmorImperialStuddedSet",
					"ArmorIronSet",
					"ArmorLeatherSet",
					"ArmorOrcSet",
					"ArmorReachHelmet",
					"ArmorScaledSet",
					"ArmorStormcloakBearSet",
					"ArmorStormcloakHelmets",
					"ArmorStormcloakSet",
					"ArmorStuddedSet",
					"BYOHHouseTestItems",
					"BYOHLItemInnRuralDrinkNewWines",
					"BYOHRelationshipAdoptionLItemChildrensClothes",
					"ClothesFarm",
					"CW01BPlayerHelpItems",
					"CWBearArmorPlayerReward",
					"CWCourierDocuments",
					"CWFinaleFactionLeaderSwordList",
					"CWPlayerUniform",
					"CWRankReward",
					"CWSoldierImperialGear",
					"CWSoldierSonsGear",
					"CWSoldierWoundedOutfit",
					"DA03AxeDeathItem",
					"DA09DawnbreakerList",
					"DA14RingDeathItem",
					"DA14StaffDeathItem",
					"DB02ShackKey",
					"DB08DeathBook",
					"DeathContainerList",
					"DeathItemDwarvenSphere",
					"DLC1DawnGuardHelmet75",
					"DLC1FalmerShamanWeapon",
					"DLC1LItemDaedric",
					"DLC1LItemDawnguard",
					"DLC1LItemDisguisedHunterInventory",
					"DLC1LItemFalmer",
					"DLC1LItemGargoyleMineralsRaw100",
					"DLC1LItemKeeper",
					"DLC1LitemStaffFalmer",
					"DLC1LItemStaffFalmer",
					"DLC1LItemVampireCuirass",
					"DLC1LItemWeaponDawnguardCrossbowLoot75Gated",
					"DLC1LItemWeaponFalmerShaman",
					"DLC1RV03HunterArmor",
					"DLC1RV05RemainsList",
					"DLC1SublistEnchCrossbow",
					"DLC1SublistEnchDwarvenCrossbow",
					"DLC1SublistEnchVampireRobes",
					"DLC1SublistKeeper",
					"DLC1SublistStaffDestructionFalmer",
					"DLC1WrathmanSummonedWeapon2H",
					"DLC2BlacksmithArmorExtra100",
					"DLC2BlankStaff",
					"DLC2Bonemold",
					"DLC2Chitin",
					"DLC2dunHaknirGhostLeveledList",
					"DLC2dunKolbjornLItemMinerClothes",
					"DLC2ExpSpiderAlbinoDeathItemButt",
					"DLC2LItemArmorBootsHeavy",
					"DLC2LItemArmorBootsLight",
					"DLC2LitemArmorBootsLight",
					"DLC2LItemArmorCuirassHeavy",
					"DLC2LItemArmorCuirassLight",
					"DLC2LItemArmorGauntletsHeavy",
					"DLC2LItemArmorGauntletsLight",
					"DLC2LItemArmorHelmetHeavy",
					"DLC2LItemArmorHelmetLight",
					"DLC2LItemArmorShieldHeavy",
					"DLC2LitemArmorShieldHeavy",
					"DLC2LItemArmorShieldLight",
					"DLC2LItemBook",
					"DLC2LItemDraugrHulkingShield67",
					"DLC2LItemDrink75",
					"DLC2LItemIldariRobesDestruction",
					"DLC2LItemIngredientFoodPrepared",
					"DLC2LItemIngredientsCommon",
					"DLC2LItemIngredientsRare",
					"DLC2LItemIngredientsUncommon",
					"DLC2LItemSpellTomes",
					"DLC2LItemSpellTOmes",
					"DLC2LitemSpellTomes",
					"DLC2LItemWeaponBattleAxe",
					"DLC2LItemWeaponBow",
					"DLC2LItemWeaponDagger",
					"DLC2LItemWeaponGreatSword",
					"DLC2LItemWeaponMace",
					"DLC2LItemWeaponSword",
					"DLC2LItemWeaponWarAxe",
					"DLC2LItemWeaponWarhammer",
					"DLC2LootRieklingSpears50",
					"DLC2MerilarRendasDeathItem",
					"DLC2MQ06Miraak",
					"DLC2NordicHeavyBoss",
					"DLC2NordicShield20",
					"DLC2OutfitSkaalHatChance50",
					"DLC2SpellBook",
					"DLC2Stalhrim",
					"DLC2SublistEnchArmor",
					"DLC2SublistEnchNordic",
					"DLC2SublistEnchStahlrim",
					"DLC2SublistEnchStalhrim",
					"dunHillgrundsTombRewardList",
					"dunLItemFolgunthurMikrulSword",
					"dunLItemFrostmereBlade",
					"dunLItemGeirmundSigdisBow",
					"dunMarkarthWizardMeleeSecurity",
					"dunSilentMoonsLItemEnch",
					"GuardGear",
					"LItemApothecaryRecipesCommon100",
					"LItemArmorBootsHeavy",
					"LItemArmorBootsLight",
					"LitemArmorBootsLight",
					"LItemArmorCuirassHeavy",
					"LItemArmorCuirassLight",
					"LItemArmorDwarven",
					"LItemArmorGauntletsHeavy",
					"LItemArmorGauntletsLight",
					"LItemArmorHelmetHeavy",
					"LItemArmorHelmetLight",
					"LItemArmorShieldHeavy",
					"LitemArmorShieldHeavy",
					"LItemArmorShieldLight",
					"LItemBandit",
					"LItemBlacksmithMinDagger",
					"LItemBook",
					"LItemClothesFarm",
					"LItemClothesRegular",
					"LItemClothesWork",
					"LItemDA13Armor",
					"LItemDawnguard",
					"LItemDragonPriestStaff100",
					"LItemDraugr",
					"LItemDwarvenOnly",
					"LItemEnchCirclet",
					"LItemEnchDaedricAny",
					"LItemEnchImperialSword",
					"LItemEnchNecklace",
					"LItemEnchNecromancerRobes",
					"LItemEnchOrcishBattleaxe",
					"LItemEnchRing",
					"LItemFalmerWeapon",
					"LItemFoodBlackBriarMead100",
					"LItemFoodChild",
					"LItemFoodHonningbrewMead100",
					"LItemFoodRaw",
					"LItemForsworn",
					"LItemGemEmpty",
					"LItemGems",
					"LItemGutterSaint",
					"LItemHunterWeaponBow",
					"LItemIngotGold50",
					"LItemIngredientFoodPrepared",
					"LItemIngredientsCommon",
					"LItemIngredientsRare",
					"LItemIngredientsUncommon",
					"LItemIngredientUncommonSame75",
					"LItemIngredientsUnderground",
					"LItemIronOrSteel",
					"LItemJewelryCirclet",
					"LItemJewelryNecklace",
					"LItemJewelryRing",
					"LItemJewelryRingSmall",
					"LitemJunk",
					"LItemLockPick100",
					"LItemLootIMineralsProcessed",
					"LItemMaceForOrcs",
					"LItemMiscVendorGems100",
					"LItemMiscVendorSoulGemEmpty",
					"LItemMiscVendorSoulGemFull",
					"LItemMS09",
					"LItemNecromancerRobes",
					"LItemOrcStronghold",
					"LItemOre",
					"LItemPenitusWeapon1H",
					"LItemPoison",
					"LItemPotion",
					"LItemReligiousSymbols",
					"LItemRobes",
					"LItemScroll",
					"LItemSilverHandWeapon",
					"LItemSoldierImperial",
					"LItemSoldierSons",
					"LItemSoulGemEmpty",
					"LItemSoulGemFull",
					"LItemSpellTomes",
					"LitemSpellTomes",
					"LItemSpellTOmes",
					"LItemStaffAlteration",
					"LItemStaffConjuration",
					"LItemStaffDestruction00",
					"LItemStaffDestruction25",
					"LItemStaffDestruction50",
					"LItemStaffDestruction75",
					"LItemStaffIllusion",
					"LItemStaffRestoration",
					"LItemSummersetShadowsArmor",
					"LItemTGAmuletofArticulation",
					"LItemThalmorDagger",
					"LItemThalmorShield",
					"LItemVampire",
					"LItemVigilant",
					"LItemWarlock",
					"LITemWarlockRobes",
					"LItemWeaponBattleAxe",
					"LItemWeaponBow",
					"LItemWeaponDagger",
					"LItemWeaponDwarven",
					"LItemWeaponGreatSword",
					"LItemWeaponMace",
					"LItemWeaponNightingale",
					"LItemWeaponSailor",
					"LItemWeaponSword",
					"LItemWeaponWarAxe",
					"LItemWeaponWarhammer",
					"LItemWEBattlemage",
					"LItemWerewolf",
					"LItemwerewolfBossWarhammer",
					"LItemWESpellsword",
					"LItemWEThief",
					"LootBanditArmor100",
					"LootDwarvenCenturionSoulGem",
					"LootFalmerOre100",
					"LootGoldChangeUrns",
					"LootSabrecatBodyParts",
					"LootStaffsNecromancy100",
					"MG04RewardLVL",
					"MGR01ItemList",
					"MGR2",
					"MGRitual",
					"MQ203AkaviriKatana",
					"MQ304TsunBattleAxe",
					"MS09Reward",
					"OutfitList",
					"PenitusGear",
					"PrisonerPants50",
					"SublistArmor",
					"SublistEnch",
					"SublistENchDaedricWarAxeAbsorb",
					"SublistScaledCuirassVariants",
					"SublistSoulGem",
					"SublistThalmor",
					"SublistWeapon",
					"TG02MercLItem",
					"TG07Chillrend",
					"TGLvlItemNightingale",
					"TGPotionof",
					"TGRewardPotion",
					"TGTQ04DeathItem",
					"UDGPDLC1SublistEnchVampireRobesMagickaRate",
					"USKPVigilantsWeaponMace",
					"USLEEPStormfang",
					"USLEEPSublistEnchDaedricBattle",
					"VendorEorlundSkyforgeSteelSet",
					"WE17BanditOutfitList"
			]
			
			locals.blacklistNPC = [
					"CWBattleTullius",
					"CWFieldCOSons",
					"CWSiege",
					"DBTreasCorpseSkeleton",
					"dunBleakFallsCorpseBretonThomas",
					"dunHonningbrewRatGuy",
					"dunMarkarthWizard_Guard",
					"DLC1dunDarkfallTreasCorpse01",
					"DLC1HunterBaseIntroVigilant",
					"DLC1VQ01VigilantTolanCorpse",
					"DLC2dunFahlbtharzExplorerCorpse",
					"DLC2dunGyldenhulAdventurer",
					"DLC2EncHunterNordM",
					"DLC2KagrumezBanditBoss",
					"DLC2MerilarRendas",
					"DLC2PillarRRGuard",
					"DLC2RR",
					"DLC2ServosRendas",
					"DLC2WE05Wizard",
					"dunCGImperialSoldierArcherA04",
					"dunPOIVolcanicLuckyLorenze",
					"e3DemoArvel",
					"E3DemoTowerBanditMissile",
					"EncForsworn",
					"EncHunter",
					"EncVigilantOfStendarr",
					"GaiusMaro",
					"Golldir",
					"Jdatharr",
					"MQ206Gormlaith",
					"MQ304Froki",
					"MS03ChaletGuardExterior",
					"Player",
					"SummonGormlaith",
					"TG08BTreasCorpseThiefNordMaleOld",
					"TG09TreasCorpseAnders",
					"TreasCorpseVigilantOfStendarrMale",
					"Urwa",
					"WEAdventurerBrawler"
			]
        
			locals.blacklistREFR = [
				"CWDummy",
				"DA16AwakeBarrierGem",
				"DBMarkarthDagger",
				"Favor",
				"FestivalSpicedWineSpigotRef",
				"SiddgeirBlackBriarMeadREF",
				"YsoldaFavorItemREF"
			]
			
			locals.blacklistTREE = [
				"BYOHHouseFloraCabbage01",
				"BYOHHouseFloraCarrots01",
				"BYOHHouseFloraGourd01",
				"BYOHHouseFloraLeek01",
				"BYOHHouseFloraPotato01",
				"BYOHHouseIngrdCanisRoot01",
				"BYOHHouseIngrdCotton01",
				"BYOHHouseIngrdCreepCluster01",
				"BYOHHouseIngrdDeathbell01",
				"BYOHHouseIngrdDragonTongue01",
				"BYOHHouseIngrdFungalPod01",
				"BYOHHouseIngrdGiantLichen01",
				"BYOHHouseIngrdGlowMushrm01",
				"BYOHHouseIngrdJazbay01",
				"BYOHHouseIngrdJuniper01",
				"BYOHHouseIngrdLavender01",
				"BYOHHouseIngrdMoraTap01",
				"BYOHHouseIngrdMtFlBlue01",
				"BYOHHouseIngrdMtFlPurple01",
				"BYOHHouseIngrdMtFlRed01",
				"BYOHHouseIngrdMushroom01",
				"BYOHHouseIngrdMushroom02",
				"BYOHHouseIngrdMushroom03",
				"BYOHHouseIngrdMushroom04",
				"BYOHHouseIngrdMushroom05",
				"BYOHHouseIngrdMushroom06",
				"BYOHHouseIngrdNightshade01",
				"BYOHHouseIngrdScalyPBits01",
				"BYOHHouseIngrdSnowberry01",
				"BYOHHouseIngrdSpikyGrass01",
				"BYOHHouseIngrdThistle01",
				"BYOHHouseIngrdWheat01",
				"DLC01AncestorsGladeTree"
			]
		},
        process: [{
			//Process REFR
			load: {
				signature: "REFR",
				overrides: false,
				filter: function(record) {
					let baseRecord = xelib.GetLinksTo(record, "NAME");
					if(xelib.Name(xelib.GetElementFile(xelib.GetWinningOverride(record))) == "Poverty.esp") {
						return false;
					} else if(!hasPovertySignature(baseRecord)) {
						return false;
					} else if(!xelib.HasElement(record, "NAME")) {
						return false;
					} else if(xelib.GetRecordFlag(record, "Initially Disabled")) {
						return false;
					} else if(xelib.Signature(xelib.GetLinksTo(record, "NAME")) == "LVLI") {
						return false;
					} else if(isInBlacklist(locals.blacklistREFR, xelib.EditorID(record))) {
						return false;
					} else if(isInBlacklist(locals.blacklist, xelib.EditorID(baseRecord))) {
						return false;
					} else {
						return true;
					}
				}
			},
			patch: function (record, helpers, settings, locals) {
				if(settings.processREFR) {
					if(settings.logCurrent) {
						helpers.logMessage(xelib.LongName(record));
					}
					let baseRecord = xelib.GetWinningOverride(xelib.GetLinksTo(record, "NAME"));
					let editorID = xelib.EditorID(baseRecord);
					
					//Add poverty LVLI record
					let lvliRecord = AddPovertyLVLI(patchFile, baseRecord, editorID, "REFR", patchFile, helpers);
					
					//Add XLIB to reference
					xelib.AddElementValue(record, "XLIB", xelib.EditorID(lvliRecord));
					//Change the name
					switch(xelib.Signature(baseRecord)) {
						case "ALCH":
							if(xelib.HasKeyword(record, "VendorItemPotion") || xelib.HasKeyword(record, "VendorItemPoison")) {
								xelib.SetValue(record, "NAME", "DummyDrink");
							} else if(xelib.GetHexFormID(xelib.GetLinksTo(baseRecord, "ENIT\\Sound - Consume"), false, false) == "000B6435") {
								xelib.SetValue(record, "NAME", "DummyDrink");
							} else {
								xelib.SetValue(record, "NAME", "DummyFood");
							}
							break;
						case "AMMO":
							xelib.SetValue(record, "NAME", "DummyArrow");
							break;
						case "ARMO":
							if(xelib.HasKeyword(baseRecord, "ArmorBoots")) {
								xelib.SetValue(record, "NAME", "DummyBoots");
							} else if(xelib.HasKeyword(baseRecord, "ArmorCuirass")) {
								xelib.SetValue(record, "NAME", "DummyCuirass");
							} else if(xelib.HasKeyword(baseRecord, "ArmorGauntlets")) {
								xelib.SetValue(record, "NAME", "DummyGauntlets");
							} else if(xelib.HasKeyword(baseRecord, "ArmorHelmet")) {
								xelib.SetValue(record, "NAME", "DummyHelmet");
							} else if(xelib.HasKeyword(baseRecord, "ArmorShield")) {
								xelib.SetValue(record, "NAME", "DummyShield");
							} else if(xelib.HasKeyword(baseRecord, "ClothingCirclet")) {
								xelib.SetValue(record, "NAME", "DummyCirclet");
							} else if(xelib.HasKeyword(baseRecord, "ClothingRing")) {
								xelib.SetValue(record, "NAME", "DummyRing");
							} else if(xelib.HasKeyword(baseRecord, "ClothingNecklace")) {
								xelib.SetValue(record, "NAME", "DummyAmulet");
							} else if(xelib.HasKeyword(baseRecord, "ClothingFeet")) {
								xelib.SetValue(record, "NAME", "DummyBoots");
							} else if(xelib.HasKeyword(baseRecord, "ClothingBody")) {
								xelib.SetValue(record, "NAME", "DummyCuirass");
							} else if(xelib.HasKeyword(baseRecord, "ClothingHands")) {
								xelib.SetValue(record, "NAME", "DummyGauntlets");
							} else if(xelib.HasKeyword(baseRecord, "ClothingHead")) {
								xelib.SetValue(record, "NAME", "DummyHelmet");
							}
							break;
						case "BOOK":
							xelib.SetValue(record, "NAME", "DummyBook");
							break;
						case "INGR":
							xelib.SetValue(record, "NAME", "DummyIngredient");
							break;
						case "MISC":
							if(editorID.includes("Gold001")) {
								xelib.SetValue(record, "NAME", "DummySeptim");
							} else if(getsReferencedByRecordWithSignature(baseRecord, "COBJ")) {
								xelib.SetValue(record, "NAME", "DummyResource");
							} else {
								xelib.SetValue(record, "NAME", "DummyClutter");
							}
							break;
						case "SLGM":
							xelib.SetValue(record, "NAME", "DummySoulGem");
							break;
						case "WEAP":
							if(xelib.HasKeyword(baseRecord, "WeapTypeBattleaxe")) {
								xelib.SetValue(record, "NAME", "DummyBattleaxe");
							} else if(xelib.HasKeyword(baseRecord, "WeapTypeBow")) {
								xelib.SetValue(record, "NAME", "DummyBow");
							} else if(xelib.HasKeyword(baseRecord, "WeapTypeDagger")) {
								xelib.SetValue(record, "NAME", "DummyDagger");
							} else if(xelib.HasKeyword(baseRecord, "WeapTypeGreatsword")) {
								xelib.SetValue(record, "NAME", "DummyGreatSword");
							} else if(xelib.HasKeyword(baseRecord, "WeapTypeMace")) {
								xelib.SetValue(record, "NAME", "DummyMace");
							} else if(xelib.HasKeyword(baseRecord, "WeapTypeSword")) {
								xelib.SetValue(record, "NAME", "DummySword");
							} else if(xelib.HasKeyword(baseRecord, "WeapTypeWarAxe")) {
								xelib.SetValue(record, "NAME", "DummyWarAxe");
							} else if(xelib.HasKeyword(baseRecord, "WeapTypeWarhammer")) {
								xelib.SetValue(record, "NAME", "DummyWarhammer");
							} else if(xelib.HasKeyword(baseRecord, "WeapTypeStaff")) {
								xelib.SetValue(record, "NAME", "DummyStaff");
							}
							break;
					}
				}
			}
		}, {
			//Process CONT
			load: {
				signature: "CONT",
				overrides: false,
				filter: function(record) {
					if(xelib.Name(xelib.GetElementFile(xelib.GetWinningOverride(record))) == "Poverty.esp") {
						return false;
					} else if(!xelib.HasElement(record, "Items")) {
						return false;
					} else if(isInBlacklist(locals.blacklistCONT, xelib.EditorID(record))) {
						return false;
					} else {
						return true;
					}
				}
			},
			patch: function (record, helpers, settings, locals) {
				if(settings.processCONT) {
					if(settings.logCurrent) {
						helpers.logMessage(xelib.LongName(record));
					}
					
					//Get previous Record
					let masterRecord = xelib.GetMasterRecord(record);
					let overrides = xelib.GetOverrides(masterRecord);
					let previousRecord;
					if(overrides.length == 1) {
						previousRecord = masterRecord;
					} else {
						previousRecord = overrides[overrides.length - 2];
					}
					
					//Cycle through items
					for(let i = 0; i < xelib.GetValue(record, "COCT").toString(); i++) {
						let item = xelib.GetLinksTo(record, "Items\\[" + i.toString() + "]\\CNTO\\Item");
						let editorID = xelib.EditorID(item);
						
						//Replace items with poverty LVLI
						if(!(("LVLI|KEYM".includes(xelib.Signature(item))) || isInBlacklist(locals.blacklist, editorID))) {
							let lvliRecord = AddPovertyLVLI(patchFile, xelib.GetWinningOverride(item), xelib.EditorID(record), "NPC_", patchFile, helpers);
							xelib.AddItem(record, xelib.EditorID(lvliRecord), xelib.GetValue(previousRecord, "Items\\[" + i.toString() + "]\\CNTO\\Count"));
							xelib.RemoveItem(record, xelib.GetValue(item, "Record Header\\FormID"));
						}
					}
				}
			}
		}, {
			//Process LVLI
			load: {
				signature: "LVLI",
				overrides: false,
				filter: function(record) {
					let masterRecord = xelib.GetMasterRecord(record);
					let overrides = xelib.GetOverrides(masterRecord);
					if(xelib.Name(xelib.GetElementFile(xelib.GetWinningOverride(record))) == "Poverty.esp") {
						return false;
					} else if(!xelib.HasElement(record, "Leveled List Entries")) {
						return false;
					} else if(isInBlacklist(locals.blacklistLVLI, xelib.EditorID(record))) {
						return false;
					} else {
						return true;
					}
				}
			},
			patch: function (record, helpers, settings, locals) {
				if(settings.processLVLI) {
					if(settings.logCurrent) {
						helpers.logMessage(xelib.LongName(record));
					}
					
					//Get previous Record
					let masterRecord = xelib.GetMasterRecord(record);
					let overrides = xelib.GetOverrides(masterRecord);
					let previousRecord;
					if(overrides.length == 1) {
						previousRecord = masterRecord;
					} else {
						previousRecord = overrides[overrides.length - 2];
					}
					
					let processedLVLICount = 0;
					
					//Cycle through leveled entries
					for(let i = 0; i < xelib.GetValue(record, "LLCT").toString(); i++) {
						let leveledlist = xelib.GetLinksTo(previousRecord, "Leveled List Entries\\[" + i.toString() + "]\\LVLO\\Reference");
						let editorID = xelib.EditorID(leveledlist);
						
						//Replace leveled entry with poverty LVLI
						if(!(("LVLI|KEYM".includes(xelib.Signature(leveledlist))) || isInBlacklist(locals.blacklist, editorID))) {
							processedLVLICount++;
							let lvliRecord = AddPovertyLVLI(patchFile, xelib.GetWinningOverride(leveledlist), xelib.EditorID(record), "LVLI", patchFile, helpers);
							xelib.AddLeveledEntry(record, xelib.EditorID(lvliRecord), "1", xelib.GetValue(previousRecord, "Leveled List Entries\\[" + i.toString() + "]\\LVLO\\Count"));
							xelib.RemoveLeveledEntry(record, xelib.GetValue(leveledlist, "Record Header\\FormID"));
						}
					}
					if(processedLVLICount != 0) {
						AddPovertyLVLIGlobal(record, helpers);
					}
				}
			}
		}, {
			//Process NPC_
			load: {
				signature: "NPC_",
				overrides: false,
				filter: function(record) {
					if(xelib.Name(xelib.GetElementFile(xelib.GetWinningOverride(record))) == "Poverty.esp") {
						return false;
					} else if(!xelib.HasElement(record, "Items")) {
						return false;
					} else if(isInBlacklist(locals.blacklistNPC, xelib.EditorID(record))) {
						return false;
					} else {
						return true;
					}
				}
			},
			patch: function (record, helpers, settings, locals) {
				if(settings.processNPC_) {
					if(settings.logCurrent) {
						helpers.logMessage(xelib.LongName(record));
					}
					
					//Get previous Record
					let masterRecord = xelib.GetMasterRecord(record);
					let overrides = xelib.GetOverrides(masterRecord);
					let previousRecord;
					if(overrides.length == 1) {
						previousRecord = masterRecord;
					} else {
						previousRecord = overrides[overrides.length - 2];
					}
					
					//Cycle through items
					for(let i = 0; i < xelib.GetValue(record, "COCT").toString(); i++) {
						let item = xelib.GetLinksTo(record, "Items\\[" + i.toString() + "]\\CNTO\\Item");
						let editorID = xelib.EditorID(item);
						
						//Replace items with poverty LVLI
						if(!(("LVLI|KEYM|WEAP".includes(xelib.Signature(item))) || (("AMMO|ARMO".includes(xelib.Signature(item))) && (xelib.GetValue(record, "Items\\[" + i.toString() + "]\\CNTO\\Count") == "1")) || isInBlacklist(locals.blacklist, editorID))) {
							let lvliRecord = AddPovertyLVLI(patchFile, xelib.GetWinningOverride(item), xelib.EditorID(record), "NPC_", patchFile, helpers);
							xelib.AddItem(record, xelib.EditorID(lvliRecord), xelib.GetValue(previousRecord, "Items\\[" + i.toString() + "]\\CNTO\\Count"));
							xelib.RemoveItem(record, xelib.GetValue(item, "Record Header\\FormID"));
						}
					}
				}
			}
		}, {
			//Process FLOR
			load: {
				signature: "FLOR",
				overrides: false,
				filter: function(record) {
					if(xelib.Name(xelib.GetElementFile(xelib.GetWinningOverride(record))) == "Poverty.esp") {
						return false;
					} else if(!xelib.HasElement(record, "PFIG")) {
						return false;
					} else if(!hasPovertySignature(xelib.GetLinksTo(record, "PFIG"))) {
						return false;
					} else if(isInBlacklist(locals.blacklistFLOR, xelib.EditorID(record))) {
						return false;
					} else {
						return true;
					}
				}
			},
			patch: function (record, helpers, settings, locals) {
				if(settings.processFLORandTREE) {
					if(settings.logCurrent) {
						helpers.logMessage(xelib.LongName(record));
					}
					let ingredient = xelib.GetLinksTo(record, "PFIG");
					let editorID = xelib.EditorID(ingredient);
					let lvliRecord = AddPovertyLVLI(patchFile, xelib.GetWinningOverride(ingredient), xelib.EditorID(record), "FLOR", patchFile, helpers);
					xelib.SetLinksTo(record, lvliRecord, "PFIG");
				}
			}
		}, {
			//Process TREE
			load: {
				signature: "TREE",
				overrides: false,
				filter: function(record) {
					if(xelib.Name(xelib.GetElementFile(xelib.GetWinningOverride(record))) == "Poverty.esp") {
						return false;
					} else if(!xelib.HasElement(record, "PFIG")) {
						return false;
					} else if(!hasPovertySignature(xelib.GetLinksTo(record, "PFIG"))) {
						return false;
					} else if(isInBlacklist(locals.blacklistTREE, xelib.EditorID(record))) {
						return false;
					} else {
						return true;
					}
				}
			},
			patch: function (record, helpers, settings, locals) {
				if(settings.processFLORandTREE) {
					if(settings.logCurrent) {
						helpers.logMessage(xelib.LongName(record));
					}
					let ingredient = xelib.GetLinksTo(record, "PFIG");
					let editorID = xelib.EditorID(ingredient);
					let lvliRecord = AddPovertyLVLI(patchFile, xelib.GetWinningOverride(ingredient), xelib.EditorID(record), "TREE", patchFile, helpers);
					xelib.SetLinksTo(record, lvliRecord, "PFIG");
				}
			}
		}],
        finalize: function () {
        }
    })
});

function isInBlacklist(blacklist, editorID) {
	let i;
	for(i = 0; i < blacklist.length; i++) {
		if(editorID.substring(0, blacklist[i].length) == blacklist[i]) {
			return true;
		}
	}
	return false;
}

function getsReferencedByRecordWithSignature(record, signature) {
	let references = xelib.GetReferencedBy(record);
	let i;
	for(i = 0; i < references.length; i++) {
		if(xelib.Signature(references[i]) == signature) {
			return true;
		}
	}
	return false;
}

function hasPovertySignature(record) {
	if("ALCH|AMMO|ARMO|BOOK|INGR|MISC|SLGM|WEAP".includes(xelib.Signature(record))) {
		return true;
	} else {
		return false;
	}
}

function AddPovertyLVLI(file, record, originEditorID, originSignature, patchFile, helpers) {
	let signature = xelib.Signature(record);
	let editorID = xelib.EditorID(record);
	
	//If reference is LVLI get the first non LVLI entry
	if(signature == "LVLI" && xelib.Signature(xelib.GetLinksTo(record, "Leveled List Entries\\[0]\\LVLO\\Reference")) == "LVLI" && xelib.HasElement(xelib.GetLinksTo(record, "Leveled List Entries\\[0]\\LVLO\\Reference"), "Leveled List Entries")) {
		var innerlvli = xelib.GetWinningOverride(xelib.GetLinksTo(record, "Leveled List Entries\\[0]\\LVLO\\Reference"));
		while(xelib.Signature(innerlvli) == "LVLI" && xelib.Signature(xelib.GetLinksTo(innerlvli, "Leveled List Entries\\[0]\\LVLO\\Reference")) == "LVLI" && xelib.HasElement(xelib.GetLinksTo(record, "Leveled List Entries\\[0]\\LVLO\\Reference"), "Leveled List Entries")) {
			innerlvli = xelib.GetWinningOverride(xelib.GetLinksTo(innerlvli, "Leveled List Entries\\[0]\\LVLO\\Reference"));
		}
		signature = xelib.Signature(innerlvli);
	}
	
	//Special cases
	if(editorID.includes("Gold001") && (originEditorID.includes("Vendor") || originEditorID.includes("Merchant"))) {
		editorID = editorID + "_MERCHANT";
	} else if(editorID.includes("SpellTome") || editorID.includes("Scroll")) {
		editorID = editorID + "_SPELL";
	} else if(originSignature == "NPC_" && (getsReferencedByRecordWithSignature(record, "COBJ") || "ALCH|AMMO|KEYM|LVLI".includes(signature))) {
		editorID = editorID + "_NPC";
	}
	
	if(!xelib.HasElement(patchFile, "LVLI\\p" + editorID)) {
		//Add LVLI record	
		let lvli = xelib.AddElement(file, "LVLI\\LVLI");
		xelib.AddElementValue(lvli, "EDID", "p" + editorID);
		xelib.SetFlag(lvli, "LVLF", "Calculate for each item in count", true);
		xelib.AddLeveledEntry(lvli, xelib.GetHexFormID(record, false, false), "1", "1");
		switch(signature) {
			case "ALCH":
				if(originSignature == "FLOR" || originSignature == "TREE") {
					xelib.AddElementValue(lvli, "LVLG", "pHarvestFoodFlora");
				} else if(editorID.includes("_NPC")) {
					xelib.AddElementValue(lvli, "LVLG", "pHarvestFoodNPC");
				} else if(xelib.GetHexFormID(xelib.GetLinksTo(record, "ENIT\\Sound - Consume"), false, false) == "000B6435") {
					xelib.AddElementValue(lvli, "LVLG", "pDrink");
				} else if(xelib.HasKeyword(record, "VendorItemPotion") || xelib.HasKeyword(record, "VendorItemPoison")) {
					xelib.AddElementValue(lvli, "LVLG", "pPotion");
				} else {
					xelib.AddElementValue(lvli, "LVLG", "pFood");
				}
				break;
			case "AMMO":
				if(editorID.includes("_NPC")){
					xelib.AddElementValue(lvli, "LVLG", "pAmmoNPC");
				} else {
					xelib.AddElementValue(lvli, "LVLG", "pAmmo");
				}
				break;
			case "ARMO":
				xelib.AddElementValue(lvli, "LVLG", "pArmor");
				break;
			case "BOOK":
				if(editorID.includes("_SPELL")){
					xelib.AddElementValue(lvli, "LVLG", "pBookSpell");
				} else {
					xelib.AddElementValue(lvli, "LVLG", "pBook");
				}
				break;
			case "INGR":
				if(originSignature == "FLOR" || originSignature == "TREE"){
					xelib.AddElementValue(lvli, "LVLG", "pHarvestIngredientsFlora");
				} else if(editorID.includes("_NPC")) {
					xelib.AddElementValue(lvli, "LVLG", "pHarvestIngredientsNPC");
				} else {
					xelib.AddElementValue(lvli, "LVLG", "pIngredient");
				}
				break;
			case "MISC":
				if(editorID.includes("_NPC")) {
					xelib.AddElementValue(lvli, "LVLG", "pHarvestResourceNPC");
				} else if(editorID.includes("_MERCHANT")) {
					xelib.AddElementValue(lvli, "LVLG", "pMerchantGold");
				} else if(editorID.includes("Gold001")) {
					xelib.AddElementValue(lvli, "LVLG", "pGold");
				} else if(getsReferencedByRecordWithSignature(record, "COBJ")) {
					xelib.AddElementValue(lvli, "LVLG", "pResource");
				} else {
					xelib.AddElementValue(lvli, "LVLG", "pClutter");
				}
				break;
			case "SCRL":
				xelib.AddElementValue(lvli, "LVLG", "pBookSpell");
				break;
			case "SLGM":
				xelib.AddElementValue(lvli, "LVLG", "pSoulGem");
				break;
			case "WEAP":
				xelib.AddElementValue(lvli, "LVLG", "pWeapon");
				break;
		}
		return lvli;
	} else {
		return xelib.GetElement(0, xelib.Path(patchFile) + "\\LVLI\\p" + editorID);
	}
	
}

function AddPovertyLVLIGlobal(record, helpers) {
	let signatures = [];
	let gold = 0;
	SearchForAllLVLISignatures(record, signatures, helpers);
	for(let i = 0; i < signatures.length; i++) {
		if(!(signatures[i] == signatures[0])) {
			helpers.logMessage("WARNING: No Global for LVLI " + xelib.EditorID(record) + " available!");
			return;
		}
	}
	
	switch(signatures[0]) {
		case "ALCH":
			xelib.AddElementValue(record, "LVLG", "pFood");
			break;
		case "AMMO":
			xelib.AddElementValue(record, "LVLG", "pAmmo");
			break;
		case "ARMO":
			xelib.AddElementValue(record, "LVLG", "pArmor");
			break;
		case "BOOK":
			xelib.AddElementValue(record, "LVLG", "pBook");
			break;
		case "INGR":
			xelib.AddElementValue(record, "LVLG", "pIngredient");
			break;
		case "MISC":
			if(gold == signatures.length) {
				xelib.AddElementValue(record, "LVLG", "pGold");
			} else {
				xelib.AddElementValue(record, "LVLG", "pClutter");
			}
			break;
		case "SCRL":
			xelib.AddElementValue(record, "LVLG", "pBookSpell");
			break;
		case "SLGM":
			xelib.AddElementValue(record, "LVLG", "pSoulGem");
			break;
		case "WEAP":
			xelib.AddElementValue(record, "LVLG", "pWeapon");
			break;
	}
}

function SearchForAllLVLISignatures(currentEntry, signatures, helpers) {
	if(xelib.Signature(currentEntry)  == "LVLI" && xelib.HasElement(currentEntry, "Leveled List Entries")) {
		for(let i = 0; i < Number(xelib.GetValue(currentEntry, "LLCT")); i++) {
			SearchForAllLVLISignatures(xelib.GetLinksTo(currentEntry, "Leveled List Entries\\[" + i.toString() + "]\\LVLO\\Reference"), signatures, helpers);
		}
	} else if(xelib.Signature(currentEntry)  != "LVLI") {
		signatures.push(xelib.Signature(currentEntry));
	}
}
