registerPatcher({
    info: info,
    gameModes: [xelib.gmTES5, xelib.gmSSE],
    settings: {
        label: 'Poverty Patcher',
        templateUrl: `${patcherUrl}/partials/settings.html`,
        defaultSettings: {
      		processREFR: true,
      		processCONT: true,
      		processFLORandTREE: true,
      		processLVLI: true,
			processNPC_: true,
			customPatch: "",
			logCurrent: true
        }
    },
    requiredFiles: ["Poverty.esp"],
	getFilesToPatch: function (filenames) {
		return filenames.filter(function(value, index, arr) {
            return (value != "Poverty.esp");
        });
    },
    execute: (patchFile, helpers, settings, locals) => ({
        initialize: function () {
			xelib.SetFileAuthor(patchFile, "evrymetul and Elscrux");
			xelib.SetFileDescription(patchFile, "All-in-One Patch for Poverty by evrymetul - Automatically generated by zEdit-Patcher by Elscrux");
			
			helpers.logMessage("Building references: This might take several minutes");
			xelib.BuildReferences(0, true);
			
			locals.blacklist = [
					"DefaultBookShelfBookMarker",
					"aaaBalokDunGlassClaw",
					"aaaBalokEnchDragonPriestDagger",
					"aaaWereBanditSpecialPick",
					"AleWhiterunQuest",
					"ArmorBoneCrown",
					"ArmorDaedricBootsarnima",
					"ArmorDaedricGauntletsarnima",
					"ArmorDragonPriestMaskWoodHelmet",
					"ArmorDwarvenHelmetarnima",
					"arnimaaximandletter",
					"ArnimaFlameAvatarSoulGem",
					"ArnimaGuardianAvatarSoulGem",
					"ArnimaHolyAvatarSoulGem",
					"arnimabelmorjournal",
					"arnimabelmornote",
					"ArnimaBlackBook",
					"arnimabook1",
					"arnimadarkburdenbook",
					"arnimadragonclaw",
					"arnimajournal",
					"ArnimaManifestSupremacyTome",
					"arnimaMaximandletter",
					"ArnimaNoteMQ9",
					"arnimaperyitecultist",
					"arnimarandomnote",
					"ArnimaReaverAvatarSoulGem",
					"ArnimaSpellMace",
					"ArnimaSpellShield",
					"ArnimaSpellTomeDarkCircle",
					"ArnimaStealthAvatarSoulGem",
					"arnimatemplenote1",
					"arnimatomefear",
					"ArnimaUnHolyAvatarSoulGem",
					"arnimavoidthought",
					"BalokBookRedguardHistory",
					"BalokDisplayRoomBook",
					"BalokHuntingBow",
					"BalokSraadomaarJournal",
					"BalokStaadonaarJournal", 
					"BalokStartUoBook",
					"BalokSteelSword",
					"BasketCarry",
					"BoneHumanSkullFullArnima",
					"bp2garden",
					"bp2skoomanote",
					"bp2wanted1",
					"BYOHHouseGuide",
					"C04HagravenHead",
					"CasSecEntranceCrest",
					"CivilWarMapFlag01",
					"CR12TotemsOfHircine",
					"CWArrow",
					"CWDummy",
					"CWFort",
					"CWIABCBarbarians",
					"CWIDissolution",
					"CWIEdictBeinaarkhNew",
					"CWIEntryExamination",
					"CWIMagickaMeteor",
					"CWIMGBootsArchmage",
					"CWIMiddenBarracksJournal",
					"CWIMiddenTempleJournalNew",
					"CWINecromancersMoon",
					"CWINelothSergiusNote",
					"CWINiryaNote",
					"CWIOrbsOfWinterhold",
					"CWIRepresentingTime",
					"CWIRunsDoll",
					"CWISealBeinaarkhNew",
					"CWISkoomaBook",
					"CWISkyrimChart",
					"CWISoulsPraxography",
					"CWIStroti",
					"CWITeleportSpellTome",
					"CWITF",
					"CWIWRCanopicJarNew",
					"CWIXU",
					"DA01",
					"DA03RuefulAxe",
					"DA04",
					"DA06Volendrung",
					"DA07",
					"DA08EbonyBlade",
					"DA13Afflicted",
					"DA14SamNote",
					"DA14SanguineRose",
					"DA14Water",
					"DA16SkullofCorruption",
					"DA16Torpor",
					"DaedricGreatswordarnima",
					"DancersFlute",
					"DB003TovaLetter",
					"DB01AventusLetter",
					"DB05ElvenBow",
					"DB06Schedule",
					"DB07Journal",
					"DBArmorGlovesReward",
					"DBBladeOfWoeReward",
					"DBCiceroJournal",
					"direnni",
					"DLC01DrawKnife",
					"DLC01DweSchematics",
					"DLC1ElderScrollBack",
					"DLC01SoulCairnReaperFragment",
					"DLC01TortureTool01",
					"DLC1BoneHawk",
					"DLC1Book3Valuable",
					"DLC1DarkfallPassageNote",
					"DLC1DawnguardRune",
					"DLC1dunRedwaterDenJournal",
					"DLC1FVBook02English",
					"DLC1IvoryCrown",
					"DLC1LD_Aetheri",
					"DLC1LD_Katria",
					"DLC1nVampireNightPowerNecklaceBats",
					"DLC1RecipeFrenzy1",
					"DLC1RuunvaldJournal",
					"DLC1SoulCairnRJPOI2Note",
					"DLC1SpellTomeConjure",
					"DLC1VQ07InitiatesEwer",
					"DLC1V",
					"DLC2Bl",
					"DLC2dunBloodskalNote01",
					"DLC2dunFahlbtharzDwarvenHelmet",
					"DLC2dunHaknirScimitar01",
					"DLC2dunKarstaagSkullItemNoName",
					"DLC2dunKolbjornBoots",
					"DLC2dunKolbjornGauntlets",
					"DLC2dunKolbjornHelm",
					"DLC2dunKolbjornMinersNote",
					"DLC2dunKolbjornSkull",
					"DLC2dunKolbjornRalisJournal",
					"DLC2dunKolbjornRing",
					"DLC2dunNchardakCube",
					"DLC2DweKagrumezControlGemInv01",
					"DLC2ExpSpiderExperimentJournal",
					"DLC2FrostmothLetter04",
					"DLC2Hork",
					"DLC2Hrodulf",
					"DLC2IldariJournal",
					"DLC2KagrumezFateBow01",
					"dlc2MerchNote",
					"DLC2POIUshaNote01",
					"DLC2RR",
					"DLC2TG",
					"DLC2TT2HeartStone",
					"Dragon_Green_BloodHeadFXArmor",
					"DremoraRobesBlackPlayable",
					"Dummy",
					"dunAbandonedPrisonNote",
					"dunAlftandDwemerStudy01",
					"dunAlftandEndrastsJournal01",
					"dunAlftandJ",
					"dunAlftandManifestJournal01",
					"dunAn",
					"dunBloatedMan",
					"dunBrokenOarHargarJournal",
					"dunC",
					"dunD",
					"dunEmbershardTatteredJournal",
					"dunF",
					"dunG",
					"dunHa",
					"dunHuntersBow",
					"dunIlinaltasDeepAdventurerJournal",
					"dunIronbindLetter",
					"dunK",
					"dunLabyrinthian",
					"DunLabyrinthianSpellTomeEquilibrium",
					"dunLiarsRetreatLonghammer",
					"dunLost",
					"dunMarkarthWizard_LabJournal",
					"dunMarkarthWizardSpiderControlStaff",
					"dunMidden",
					"dunMistwatch",
					"dunMovarthsBoots",
					"dunMzinchaleft",
					"dunN",
					"dunOrotheimJournal",
					"dunP",
					"DunP",
					"DUNPOIDragonAttackNote",
					"dunR",
					"dunSaarthalStaffJyrikStaff",
					"dunSerpentsBluffNote",
					"dunShipwreck04TriusNote",
					"dunSilentMoonsLunarBook",
					"dunSteamcragCampNote",
					"dunT",
					"dunU",
					"dunV",
					"dunW",
					"dunYng",
					"DunYngolBarrowSteelPlateHelmet",
					"DwarvenWarhammerarnima",
					"EnchArmorDraugrHelmetResistFire03",
					"EnchCircletWaterbreathing",
					"EnchDraugrGreatswordHonedFire03",
					"EnchRingTwoHanded05arnima",
					"EnchSteelBattleaxeFierySouls",
					"ExecutionerAxearnima",
					"Favor",
					"FF",
					"FirebrandWine",
					"Freeform",
					"FSArmorReinforcedGuard",
					"FSArmorStaalgarde",
					"FSBjarrikWaterbreathing",
					"FSdun",
					"FSMQ0",
					"FSPlayerHomeLodgeLetter",
					"FSSkullCrusher",
					"FSSpellTomeO",
					"FSSQ",
					"FSTest",
					"FSVanvirsMasterpiece",
					"FXdustDropMedWEP",
					"highGateRuinsScroll",
					"HumanFlesharnima",
					"ImperialWarHorn",
					"IronSwordBrokenHandle",
					"IronWarAxeBroken",
					"Letter",
					"Markarth",
					"MASBalRanJournal",
					"MASBlackHandsDagger",
					"MASChrysamere",
					"MASCourierLetter",
					"MASDoranaHammer",
					"MASFinalTrial",
					"MASFirstQuestion",
					"MASKagrenacHeart",
					"MASKagrenarBook",
					"MASKeeningReplica",
					"MASKillRing",
					"MASMandynMT",
					"MASMTCongrats",
					"MASSecondQuestion",
					"MASSunderReplica",
					"MASThirdQuestion",
					"MASThreeDog",
					"MASWraithguardReplica",
					"MG03Book",
					"MGRArniel04SoulGem",
					"MGRDestruction",
					"MGRitual02Book",
					"MGRKeening",
					"mjb_Book",
					"mjb_DarkwaterCrossingNote01",
					"mjb_DawnstarQ01Journal",
					"mjb_RoriksteadNote",
					"mjb_RoriksteadQ01Journal",
					"MQ103FarengarBook",
					"MQ105Note",
					"MQ106DragonParchment",
					"MQPaarthurnaxBook",
					"MS",
					"NecroAntiochJournal",
					"NecroArkayPriestHeart",
					"NecroBlackBook01",
					"NecroBlackDye",
					"NecroBloodroot",
					"NecroCaravanAttackOrders01",
					"NecroConstructSkeletonNote01",
					"NecroGreenDye",
					"NecroJournal01",
					"NecroLichJournal",
					"NecroLichSpellKey",
					"NecroQuest04AlchemistNote",
					"NecroScourgBarrowBook01",
					"NecroScourgBarrowMinionJournal",
					"NecroSewerLaboratoryUpgrade",
					"NecroTomeofUnlife",
					"NecroTowerLaboratoryUpgrade",
					"NecroVigilantLetter01",
					"NecroVyngaldShroud",
					"NN01SinderionsJournal",
					"POI",
					"sc_ArvakSkullUNIQUE",
					"SkinDragonPriestFXMist",
					"SolitudeToryggWarHorn",
					"SpellTomearnimaFlayingBolt",
					"SpellTomearnimaPoxBarrage",
					"SpellTomearnimaSpite",
					"SpellTomeConjureDaedrothNew",
					"SpellTomeConjureScampNew",
					"SpellTomeConstructSkeleton",
					"SpellTomeDecay",
					"SpellTomeEnervate",
					"SpellTomeMassReanimate",
					"SpellTomeTransmuteOreMineral",
					"SovRoastOx",
					"SteelBattleAxeBroken",
					"T0",
					"TG00MadesiRing",
					"TG01HaelgaStatue",
					"TG02BillofSale",
					"TG03SabjornLetter",
					"TG04",
					"TG05GallusJournalPre",
					"TG07Chillrend001",
					"TG07MercersPlans",
					"TG08SkeletonKey",
					"TGBook0NightingalesVolume",
					"TGCrown",
					"TGFenceCaravanSatchel",
					"TGLT",
					"TGTQ",
					"TGRFOValueItem",
					"TGRGeneralValueItem",
					"TGTQ03SolitudeLetter",
					"TrapDweBallistaBoltAmmo01",
					"Windhelm",
					"YsgramorsBladePiece07",
					"_Lull_Archerons",
					"_Lull_AtlantanPneuma",
					"_Lull_Bear",
					"_Lull_Book10",
					"_Lull_Book11",
					"_Lull_Book2",
					"_Lull_Book3",
					"_Lull_Book6",
					"_Lull_Cave_Battery",
					"_Lull_Cave_Drill",
					"_lull_cheaterMessage",
					"_lull_divingHelmet",
					"_Lull_GateAddress",
					"_lull_gem",
					"_Lull_IdiotsLantern",
					"_Lull_MemodermicSword",
					"_Lull_Shotmold",
					"_Lull_Stone"
			]
			
			locals.whitelist = [
				
			]

			locals.blacklistCONT = [
				"ArnimaArmorContainerResource",
				"ArnimaSpellContainerResource",
				"BalokTest",
				"CCF_AllClothing",
				"CWI_Container_All",
				"DEMO",
				"DLC01QA",
				"DLC02QA",
				"DLC2dunFrostmoonVendorChest",
				"DLC2MaximianPack",
				"e3DEMO",
				"E3Demo",
				"MASSelyseTestChest",
				"MQ101BarracksChest02",
				"MQ201ElenwenOfficeChest",
				"QA",
				"SkyHavenArmoryChest"
			]
			
			locals.whitelistCONT = [
				
			]

			locals.blacklistFLOR = [
				"CoinPurse",
				"BYOHMead",
				"TGCoinPurse"
			]
			
			locals.whitelistFLOR = [

			]

			locals.blacklistLVLI = [
					"ArmorCompanionsSet",
					"ArmorElvenSet",
					"ArmorGlassSet",
					"ArmorHideSet",
					"ArmorImperialHeavyHelmets",
					"ArmorImperialHeavySet",
					"ArmorImperialLightSet",
					"ArmorImperialStuddedSet",
					"ArmorIronSet",
					"ArmorLeatherSet",
					"ArmorOrcSet",
					"ArmorReachHelmet",
					"ArmorScaledSet",
					"ArmorStormcloakBearSet",
					"ArmorStormcloakHelmets",
					"ArmorStormcloakSet",
					"ArmorStuddedSet",
					"BYOHHouseTestItems",
					"ClothesFarm",
					"CW01BPlayerHelpItems",
					"CWBearArmorPlayerReward",
					"CWCourierDocuments",
					"CWFinaleFactionLeaderSwordList",
					"CWPlayerUniform",
					"CWRankReward",
					"CWSoldierImperialGear",
					"CWSoldierSonsGear",
					"CWSoldierWoundedOutfit",
					"DA03AxeDeathItem",
					"DA09DawnbreakerList",
					"DA14RingDeathItem",
					"DA14StaffDeathItem",
					"DB02ShackKey",
					"DB08DeathBook",
					"DeathContainerList",
					"DeathItemDwarvenSphere",
					"DLC1DawnGuardHelmet75",
					"DLC1FalmerShamanWeapon",
					"DLC1LItemDawnguard",
					"DLC1LItemDisguisedHunterInventory",
					"DLC1LItemFalmer",
					"DLC1LItemKeeper",
					"DLC1LitemStaffFalmer",
					"DLC1LItemStaffFalmer",
					"DLC1LItemVampireCuirass",
					"DLC1LItemWeaponDawnguardCrossbowLoot75Gated",
					"DLC1LItemWeaponFalmerShaman",
					"DLC1RV03HunterArmor",
					"DLC1RV05RemainsList",
					"DLC1SublistEnchCrossbow",
					"DLC1SublistEnchDwarvenCrossbow",
					"DLC1SublistEnchVampireRobes",
					"DLC1SublistKeeper",
					"DLC1SublistStaffDestructionFalmer",
					"DLC1WrathmanSummonedWeapon2H",
					"DLC2Bonemold",
					"DLC2Chitin",
					"DLC2dunHaknirGhostLeveledList",
					"DLC2dunKolbjornLItemMinerClothes",
					"DLC2ExpSpiderAlbinoDeathItemButt",
					"DLC2LItemDraugrHulkingShield67",
					"DLC2LItemIldariRobesDestruction",
					"DLC2LItemIngredientFoodPrepared",
					"DLC2LItemSpellTomes",
					"DLC2LItemSpellTOmes",
					"DLC2LitemSpellTomes",
					"DLC2LItemWeaponBattleAxeDremora",
					"DLC2LItemWeaponBowDremora",
					"DLC2LItemWeaponDaggerDremora",
					"DLC2LItemWeaponGreatSwordDremora",
					"DLC2LItemWeaponMaceDremora",
					"DLC2LItemWeaponSwordDremora",
					"DLC2LItemWeaponWarAxeDremora",
					"DLC2LItemWeaponWarhammerDremora",
					"DLC2LootRieklingSpears50",
					"DLC2MerilarRendasDeathItem",
					"DLC2MQ06Miraak",
					"DLC2NordicHeavyBoss",
					"DLC2NordicShield20",
					"DLC2OutfitSkaalHatChance50",
					"DLC2SpellBook",
					"DLC2Stalhrim",
					"DLC2SublistEnchArmor",
					"DLC2SublistEnchNordic",
					"DLC2SublistEnchStahlrim",
					"DLC2SublistEnchStalhrim",
					"dunHillgrundsTombRewardList",
					"dunLItemFolgunthurMikrulSword",
					"dunLItemFrostmereBlade",
					"dunLItemGeirmundSigdisBow",
					"dunMarkarthWizardMeleeSecurity",
					"dunSilentMoonsLItemEnch",
					"FSLItemIngotAny",
					"FSLItemPelt",
					"FSLItemWeaponTownsfolkBorvald80",
					"FSMQ08LItem08SoldierGoodWeaponAny",
					"GuardGear",
					"HunterHatChance50_CCF",
					"LItemArmor",
					"LitemArmorShieldHeavyTown",
					"LItemBandit",
					"LItemBlacksmithMinDagger",
					"LItemClothesFarm",
					"LItemDA13Armor",
					"LItemDawnguard",
					"LItemDLC2ClothesDarkElfBlue",
					"LItemDLC2ClothesDarkElfBrn",
					"LItemDLC2ClothesDarkElfRed",
					"LItemDragonPriestStaff100",
					"LItemDraugr0",
					"LItemDraugrEbonyShield50",
					"LItemDraugrShield100",
					"LItemDraugrShield50",
					"LItemDraugrSword",
					"LItemEnchHoodMagickaRate_Black_CCF",
					"LItemEnchImperialSword",
					"LItemEnchNecromancerRobes",
					"LItemEnchOrcishBattleaxe",
					"LItemFalmerWeapon",
					"LItemForsworn",
					"LItemGutterSaint",
					"LItemHoodsBlueWhite_CCF",
					"LItemHoodsRedOrange_CCF",
					"LItemHunterWeaponBow",
					"LItemIngotGold50",
					"LItemIngredientUncommonSame75",
					"LItemIronOrSteel",
					"LitemJunk",
					"LItemMaceForOrcs",
					"LItemMS09",
					"LItemOrcStronghold",
					"LItemOre",
					"LItemPenitusWeapon1H",
					"LItemReligiousSymbols",
					"LItemScroll",
					"LItemSilverHandWeapon",
					"LItemSpellTomes",
					"LitemSpellTomes",
					"LItemSpellTOmes",
					"LItemSoldierImperialArmorSet",
					"LItemSoldierSonsArmorSet",
					"LItemSoldierSonsBattleaxe",
					"LItemSoldierSonsGreatsword",
					"LItemSoldierSonsMace",
					"LItemSoldierSonsSword",
					"LItemSoldierSonsWaraxe",
					"LItemSoldierSonsWarhammer",
					"LItemSoldierSonsWeapon",
					"LItemStaffAlteration",
					"LItemStaffConjuration",
					"LItemStaffDestruction00",
					"LItemStaffDestruction25",
					"LItemStaffDestruction50",
					"LItemStaffDestruction75",
					"LItemStaffIllusion",
					"LItemStaffRestoration",
					"LItemSummersetShadowsArmor",
					"LItemTGAmuletofArticulation",
					"LItemThalmorDagger",
					"LItemThalmorShield",
					"LItemVampire",
					"LItemVigilantHeavy",
					"LItemVigilantHood",
					"LItemVigilantRobes",
					"LItemWarlockDagger",
					"LITemWarlockRobes",
					"LItemWeaponBattleAxe",
					"LItemWeaponBow",
					"LItemWeaponDagger",
					"LItemWeaponDwarven",
					"LItemWeaponGreatSword",
					"LItemWeaponMace",
					"LItemWeaponNightingale",
					"LItemWeaponSailor",
					"LItemWeaponSword",
					"LItemWeaponWarAxe",
					"LItemWeaponWarhammer",
					"LItemWEBattlemage",
					"LItemWerewolf",
					"LItemwerewolfBossWarhammer",
					"LItemWESpellsword",
					"LItemWEThief",
					"LootBanditArmor100",
					"LootGoldChangeUrns",
					"LootSabrecatBodyParts",
					"LootStaffsNecromancy100",
					"MG04RewardLVL",
					"MGR01ItemList",
					"MGR2",
					"MGRitual",
					"MQ203AkaviriKatana",
					"MQ304TsunBattleAxe",
					"MS09Reward",
					"OutfitList",
					"PenitusGear",
					"PrisonerPants50",
					"RegionalHunterBoots",
					"RegionalHunterClothes",
					"RegionalHunterGloves",
					"RegionalVigilantHood",
					"SublistArmor",
					"SublistEnch",
					"SublistENchDaedricWarAxeAbsorb",
					"SublistScaledCuirassVariants",
					"SublistThalmor",
					"SublistWeapon",
					"TG02MercLItem",
					"TG07Chillrend",
					"TGLvlItemNightingale",
					"TGPotionof",
					"TGRewardPotion",
					"TGTQ04DeathItem",
					"UDGPDLC1SublistEnchVampireRobesMagickaRate",
					"USKPVigilantsWeaponMace",
					"USLEEPStormfang",
					"USLEEPSublistEnchDaedricBattle",
					"VendorEorlundSkyforgeSteelSet",
					"WE17BanditOutfitList"
			]
			
			locals.whitelistLVLI = [
				"LItemArmorBootsHeavyBlacksmith",
				"LItemArmorBootsHeavySpecial",
				"LitemArmorBootsLightBlacksmith",
				"LItemArmorBootsLightSpecial",
				"LItemArmorCuirassHeavyBlacksmith",
				"LItemArmorCuirassHeavySpecial",
				"LItemArmorCuirassLightBlacksmith",
				"LItemArmorCuirassLightSpecial",
				"LItemArmorDwarvenCuirassHeavy",
				"LItemArmorDwarvenGauntletsHeavy",
				"LItemArmorDwarvenHelmetHeavy",
				"LItemArmorGauntletsHeavyBlacksmith",
				"LItemArmorGauntletsHeavySpecial",
				"LItemArmorGauntletsLightBlacksmith",
				"LItemArmorGauntletsLightSpecial",
				"LItemArmorHelmetHeavyBest",
				"LItemArmorHelmetHeavyBlacksmith",
				"LItemArmorHelmetHeavySpecial",
				"LItemArmorHelmetLightBest",
				"LItemArmorHelmetLightBlacksmith",
				"LItemArmorHelmetLightSpecial",
				"LitemArmorShieldHeavyBlacksmith",
				"LItemArmorShieldHeavySpecial",
				"LItemArmorShieldLightBest",
				"LItemArmorShieldLightBlacksmith",
				"LItemArmorShieldLightSpecial",
				"LItemBanditHideHelmetVariants",
				"LItemClothesFarmAll",
				"LItemForswornBossHelmet",
				"LItemForswornMace",
				"LItemForswornSword",
				"LItemForswornWarAxe",
				"LItemForswornWeaponArrows",
				"LItemOrcStrongholdGreatsword",
				"LItemVampireWeaponBow",
				"LItemWeaponBattleAxeBlacksmith",
				"LItemWeaponBowBlacksmith",
				"LItemWeaponDaggerBlacksmith",
				"LItemWeaponGreatSwordBlacksmith",
				"LItemWeaponMaceBlacksmith",
				"LItemWeaponSwordBlacksmith",
				"LItemWeaponWarAxeBlacksmith",
				"LItemWeaponWarhammerBlacksmith"
			]

			locals.blacklistNPC = [
					"CWBattleTullius",
					"CWFieldCOSons",
					"CWSiege",
					"DBTreasCorpseSkeleton",
					"dunBleakFallsCorpseBretonThomas",
					"dunHonningbrewRatGuy",
					"dunMarkarthWizard_Guard",
					"DLC1dunDarkfallTreasCorpse01",
					"DLC1HunterBaseIntroVigilant",
					"DLC1VQ01VigilantTolanCorpse",
					"DLC2dunFahlbtharzExplorerCorpse",
					"DLC2dunGyldenhulAdventurer",
					"DLC2EncHunterNordM",
					"DLC2KagrumezBanditBoss",
					"DLC2MerilarRendas",
					"DLC2PillarRRGuard",
					"DLC2RR",
					"DLC2ServosRendas",
					"DLC2WE05Wizard",
					"dunCGImperialSoldierArcherA04",
					"dunPOIVolcanicLuckyLorenze",
					"e3DemoArvel",
					"E3DemoTowerBanditMissile",
					"EncForsworn",
					"EncHunter",
					"EncVigilantOfStendarr",
					"GaiusMaro",
					"Golldir",
					"Jdatharr",
					"MQ206Gormlaith",
					"MQ304Froki",
					"MS03ChaletGuardExterior",
					"Player",
					"SummonGormlaith",
					"TG08BTreasCorpseThiefNordMaleOld",
					"TG09TreasCorpseAnders",
					"TreasCorpseVigilantOfStendarrMale",
					"Urwa",
					"WEAdventurerBrawler"
			]
		
			locals.whitelistNPC = [
				
			]

			locals.blacklistREFR = [
				"CWDummy",
				"DA16AwakeBarrierGem",
				"DBMarkarthDagger",
				"Favor",
				"FestivalSpicedWineSpigotRef",
				"SiddgeirBlackBriarMeadREF",
				"YsoldaFavorItemREF"
			]
			
			locals.whitelistREFR = [
				
			]

			locals.blacklistTREE = [
				"BYOHHouseFlora",
				"BYOHHouseIngrd",
				"DLC01AncestorsGladeTree"
			]
		
			locals.whitelistTREE = [
				
			]

			locals.merchantGold = [
				"Merchant",
				"Vendor",
				"PerkInvestorStoreUpgrade",
				"PerkMasterTraderGold",
				"KRY_Variable01Gold",
				"KRY_Variable02Gold",
				"KRY_Variable03Gold"
			]

			locals.npcFood = [
				"CreatureMeat"
			]

			locals.npcIngredient = [
				"CreatureIngr",
				"CreaturePerkIngr"
			]
			
			locals.npcResource = [

			]

			locals.spellBook = [
				"arnimabloodhexbook",
				"arnimaburst",
				"arnimadarkburdenbook",
				"ArnimaFrigid",
				"ArnimaGoldBoltTome",
				"ArnimaHealTurretTome",
				"ArnimaInfernalWatcherTome",
				"ArnimaRanger",
				"ArnimaRetributionTome",
				"ArnimaStorm",
				"arnimatomefear"
			]
		},
        process: [{
			//Process REFR
			load: {
				signature: "REFR",
				overrides: false,
				filter: function(record) {
					let baseRecord = xelib.GetLinksTo(record, "NAME");
					if(!settings.processREFR) {
						return false;
					} else if(xelib.Name(xelib.GetElementFile(xelib.GetWinningOverride(record))) == "Poverty.esp") {
						return false;
					} else if(!"ALCH|AMMO|ARMO|BOOK|INGR|MISC|SLGM|WEAP".includes(xelib.Signature(baseRecord))) {
						return false;
					} else if(!xelib.HasElement(record, "NAME")) {
						return false;
					} else if(xelib.GetRecordFlag(record, "Initially Disabled")) {
						return false;
					} else if(xelib.Signature(xelib.GetLinksTo(record, "NAME")) == "LVLI") {
						return false;
					} else if(isInList(locals.blacklistREFR, xelib.EditorID(record)) && !isInList(locals.whitelistREFR, xelib.EditorID(record))) {
						return false;
					} else if(isInList(locals.blacklist, xelib.EditorID(baseRecord)) && !isInList(locals.whitelist, xelib.EditorID(baseRecord))) {
						return false;
					} else {
						return true;
					}
				}
			},
			patch: function (record, helpers, settings, locals) {
				if(settings.logCurrent) {
					helpers.logMessage(xelib.LongName(record));
				}
				let baseRecord = xelib.GetWinningOverride(xelib.GetLinksTo(record, "NAME"));
				let editorID = xelib.EditorID(baseRecord);
				
				//Add poverty LVLI record
				let lvliRecord = AddPovertyLVLI(patchFile, baseRecord, editorID, "REFR", patchFile, locals, helpers);
				
				//Add XLIB to reference
				xelib.AddElementValue(record, "XLIB", xelib.EditorID(lvliRecord));
				
				//Change the name
				switch(xelib.Signature(baseRecord)) {
					case "ALCH":
						if(xelib.HasKeyword(record, "VendorItemPotion") || xelib.HasKeyword(record, "VendorItemPoison")) {
							xelib.SetValue(record, "NAME", "DummyDrink");
						} else if(xelib.HasElement(record, "ENIT\\Sound - Consume") && xelib.GetValue(record, "ENIT\\Sound - Consume") != "NULL - Null Reference [00000000]" && xelib.GetHexFormID(xelib.GetLinksTo(record, "ENIT\\Sound - Consume"), false, false) == "000B6435") {
							xelib.SetValue(record, "NAME", "DummyDrink");
						} else {
							xelib.SetValue(record, "NAME", "DummyFood");
						}
						break;
					case "AMMO":
						xelib.SetValue(record, "NAME", "DummyArrow");
						break;
					case "ARMO":
						if(xelib.HasKeyword(baseRecord, "ArmorBoots")) {
							xelib.SetValue(record, "NAME", "DummyBoots");
						} else if(xelib.HasKeyword(baseRecord, "ArmorCuirass")) {
							xelib.SetValue(record, "NAME", "DummyCuirass");
						} else if(xelib.HasKeyword(baseRecord, "ArmorGauntlets")) {
							xelib.SetValue(record, "NAME", "DummyGauntlets");
						} else if(xelib.HasKeyword(baseRecord, "ArmorHelmet")) {
							xelib.SetValue(record, "NAME", "DummyHelmet");
						} else if(xelib.HasKeyword(baseRecord, "ArmorShield")) {
							xelib.SetValue(record, "NAME", "DummyShield");
						} else if(xelib.HasKeyword(baseRecord, "ClothingCirclet")) {
							xelib.SetValue(record, "NAME", "DummyCirclet");
						} else if(xelib.HasKeyword(baseRecord, "ClothingRing")) {
							xelib.SetValue(record, "NAME", "DummyRing");
						} else if(xelib.HasKeyword(baseRecord, "ClothingNecklace")) {
							xelib.SetValue(record, "NAME", "DummyAmulet");
						} else if(xelib.HasKeyword(baseRecord, "ClothingFeet")) {
							xelib.SetValue(record, "NAME", "DummyBoots");
						} else if(xelib.HasKeyword(baseRecord, "ClothingBody")) {
							xelib.SetValue(record, "NAME", "DummyCuirass");
						} else if(xelib.HasKeyword(baseRecord, "ClothingHands")) {
							xelib.SetValue(record, "NAME", "DummyGauntlets");
						} else if(xelib.HasKeyword(baseRecord, "ClothingHead")) {
							xelib.SetValue(record, "NAME", "DummyHelmet");
						}
						break;
					case "BOOK":
						xelib.SetValue(record, "NAME", "DummyBook");
						break;
					case "INGR":
						xelib.SetValue(record, "NAME", "DummyIngredient");
						break;
					case "MISC":
						if(editorID.includes("Gold001")) {
							xelib.SetValue(record, "NAME", "DummySeptim");
						} else if(getsReferencedByRecordWithSignature(baseRecord, "COBJ", "")) {
							xelib.SetValue(record, "NAME", "DummyResource");
						} else {
							xelib.SetValue(record, "NAME", "DummyClutter");
						}
						break;
					case "SLGM":
						xelib.SetValue(record, "NAME", "DummySoulGem");
						break;
					case "WEAP":
						if(xelib.HasKeyword(baseRecord, "WeapTypeBattleaxe")) {
							xelib.SetValue(record, "NAME", "DummyBattleaxe");
						} else if(xelib.HasKeyword(baseRecord, "WeapTypeBow")) {
							xelib.SetValue(record, "NAME", "DummyBow");
						} else if(xelib.HasKeyword(baseRecord, "WeapTypeDagger")) {
							xelib.SetValue(record, "NAME", "DummyDagger");
						} else if(xelib.HasKeyword(baseRecord, "WeapTypeGreatsword")) {
							xelib.SetValue(record, "NAME", "DummyGreatSword");
						} else if(xelib.HasKeyword(baseRecord, "WeapTypeMace")) {
							xelib.SetValue(record, "NAME", "DummyMace");
						} else if(xelib.HasKeyword(baseRecord, "WeapTypeSword")) {
							xelib.SetValue(record, "NAME", "DummySword");
						} else if(xelib.HasKeyword(baseRecord, "WeapTypeWarAxe")) {
							xelib.SetValue(record, "NAME", "DummyWarAxe");
						} else if(xelib.HasKeyword(baseRecord, "WeapTypeWarhammer")) {
							xelib.SetValue(record, "NAME", "DummyWarhammer");
						} else if(xelib.HasKeyword(baseRecord, "WeapTypeStaff")) {
							xelib.SetValue(record, "NAME", "DummyStaff");
						}
						break;
				}
			}
		}, {
			//Process CONT
			load: {
				signature: "CONT",
				overrides: false,
				filter: function(record) {
					if(!settings.processCONT) {
						return false;
					} else if(xelib.Name(xelib.GetElementFile(xelib.GetWinningOverride(record))) == "Poverty.esp") {
						return false;
					} else if(!xelib.HasElement(record, "Items")) {
						return false;
					} else if(isInList(locals.blacklistCONT, xelib.EditorID(record)) && !isInList(locals.whitelistCONT, xelib.EditorID(record))) {
						return false;
					} else {
						return true;
					}
				}
			},
			patch: function (record, helpers, settings, locals) {
				if(settings.logCurrent) {
					helpers.logMessage(xelib.LongName(record));
				}
				
				//Get previous Record
				let masterRecord = xelib.GetMasterRecord(record);
				let overrides = xelib.GetOverrides(masterRecord);
				let previousRecord;
				if(overrides.length == 1) {
					previousRecord = masterRecord;
				} else {
					previousRecord = overrides[overrides.length - 2];
				}
				let previousFile = xelib.Name(xelib.GetElementFile(previousRecord));

				
				//Cycle through items
				for(let i = 0; i < xelib.GetValue(previousRecord, "COCT"); i++) {
					let item = xelib.GetLinksTo(previousRecord, "Items\\[" + i.toString() + "]\\CNTO\\Item");
					let editorID = xelib.EditorID(item);
					//Replace items with poverty LVLI
					if((previousFile == settings.customPatch || "Smashed Patch.esp|Bashed Patch, 0.esp".includes(previousFile)) && xelib.Name(xelib.GetElementFile(item)) == "Poverty.esp") {
						xelib.RemoveItem(record, xelib.GetValue(item, "Record Header\\FormID"));
					} else if(!(("LVLI|KEYM".includes(xelib.Signature(item))) || (isInList(locals.blacklist, editorID) && !isInList(locals.whitelist, editorID)))) {
						let lvliRecord = AddPovertyLVLI(patchFile, xelib.GetWinningOverride(item), xelib.EditorID(record), "CONT", patchFile, locals, helpers);
						xelib.AddItem(record, xelib.EditorID(lvliRecord), xelib.GetValue(previousRecord, "Items\\[" + i.toString() + "]\\CNTO\\Count"));
						xelib.RemoveItem(record, xelib.GetValue(item, "Record Header\\FormID"));
					}
				}
			}
		}, {
			//Process LVLI
			load: {
				signature: "LVLI",
				overrides: false,
				filter: function(record) {
					let masterRecord = xelib.GetMasterRecord(record);
					let overrides = xelib.GetOverrides(masterRecord);
					if(!settings.processLVLI) {
						return false;
					} else if(xelib.Name(xelib.GetElementFile(xelib.GetWinningOverride(record))) == "Poverty.esp") {
						return false;
					} else if(!xelib.HasElement(record, "Leveled List Entries")) {
						return false;
					} else if(isInList(locals.blacklistLVLI, xelib.EditorID(record)) && !isInList(locals.whitelistLVLI, xelib.EditorID(record))) {
						return false;
					} else if(getsReferencedByRecordWithSignature(record, "OTFT", "")) {
						return false;
					} else {
						return true;
					}
				}
			},
			patch: function (record, helpers, settings, locals) {
				if(settings.logCurrent) {
					helpers.logMessage(xelib.LongName(record));
				}
				
				//Get previous Record
				let masterRecord = xelib.GetMasterRecord(record);
				let overrides = xelib.GetOverrides(masterRecord);
				let previousRecord;
				if(overrides.length == 1) {
					previousRecord = masterRecord;
				} else {
					previousRecord = overrides[overrides.length - 2];
				}
				let previousFile = xelib.Name(xelib.GetElementFile(previousRecord));
				
				let getsReferencedByFloraRecord = getsReferencedByRecordWithSignature(previousRecord, "FLOR", "TREE");

				//Cycle through leveled entries
				for(let i = 0; i < xelib.GetValue(previousRecord, "LLCT"); i++) {
					let leveledEntry = xelib.GetLinksTo(previousRecord, "Leveled List Entries\\[" + i.toString() + "]\\LVLO\\Reference");
					//Replace leveled entry with poverty LVLI
					if((previousFile == settings.customPatch || "Smashed Patch.esp|Bashed Patch, 0.esp".includes(previousFile)) && xelib.Name(xelib.GetElementFile(leveledEntry)) == "Poverty.esp") {
						xelib.RemoveLeveledEntry(record, xelib.GetValue(leveledEntry, "Record Header\\FormID"));
					} else if(!(xelib.GetValue(previousRecord, "Leveled List Entries\\[" + i.toString() + "]\\LVLO\\Reference").includes("< Error: Could not be resolved >") || ("LVLI|KEYM".includes(xelib.Signature(leveledEntry))) || (isInList(locals.blacklist, xelib.EditorID(leveledEntry)) && !isInList(locals.whitelist, xelib.EditorID(leveledEntry))))) {
						//Exchange the old leveled entry with a poverty variant
						let lvliRecord;
						if(getsReferencedByFloraRecord) {
							lvliRecord = AddPovertyLVLI(patchFile, xelib.GetWinningOverride(leveledEntry), xelib.EditorID(record), "FLOR", patchFile, locals, helpers);
						} else {
							lvliRecord = AddPovertyLVLI(patchFile, xelib.GetWinningOverride(leveledEntry), xelib.EditorID(record), "LVLI", patchFile, locals, helpers);
						}
						xelib.AddLeveledEntry(record, xelib.EditorID(lvliRecord), xelib.GetValue(previousRecord, "Leveled List Entries\\[" + i.toString() + "]\\LVLO\\Level"), xelib.GetValue(previousRecord, "Leveled List Entries\\[" + i.toString() + "]\\LVLO\\Count"));
						xelib.RemoveLeveledEntry(record, xelib.GetValue(leveledEntry, "Record Header\\FormID"));
					}
				}
			}
		}, {
			//Process NPC_
			load: {
				signature: "NPC_",
				overrides: false,
				filter: function(record) {
					if(!settings.processNPC_) {
						return false;
					} else if(xelib.Name(xelib.GetElementFile(xelib.GetWinningOverride(record))) == "Poverty.esp") {
						return false;
					} else if(!xelib.HasElement(record, "Items")) {
						return false;
					} else if(isInList(locals.blacklistNPC, xelib.EditorID(record)) && !isInList(locals.whitelistNPC, xelib.EditorID(record))) {
						return false;
					} else {
						return true;
					}
				}
			},
			patch: function (record, helpers, settings, locals) {
				if(settings.logCurrent) {
					helpers.logMessage(xelib.LongName(record));
				}
				
				//Get previous Record
				let masterRecord = xelib.GetMasterRecord(record);
				let overrides = xelib.GetOverrides(masterRecord);
				let previousRecord;
				if(overrides.length == 1) {
					previousRecord = masterRecord;
				} else {
					previousRecord = overrides[overrides.length - 2];
				}
				let previousFile = xelib.Name(xelib.GetElementFile(previousRecord));

				//Cycle through items
				for(let i = 0; i < xelib.GetValue(previousRecord, "COCT"); i++) {
					let item = xelib.GetLinksTo(previousRecord, "Items\\[" + i.toString() + "]\\CNTO\\Item");
					let editorID = xelib.EditorID(item);
					let signature = xelib.Signature(item);
					//Replace items with poverty LVLI
					if((previousFile == settings.customPatch || "Smashed Patch.esp|Bashed Patch, 0.esp".includes(previousFile)) && xelib.Name(xelib.GetElementFile(item)) == "Poverty.esp") {
						xelib.RemoveItem(record, xelib.GetValue(item, "Record Header\\FormID"));
					} else if(!("LVLI|KEYM|WEAP".includes(signature) || (("AMMO|ARMO".includes(signature)) && (xelib.GetValue(record, "Items\\[" + i.toString() + "]\\CNTO\\Count") == "1")) || (isInList(locals.blacklist, editorID) && !isInList(locals.whitelist, editorID)))) {
						let lvliRecord = AddPovertyLVLI(patchFile, xelib.GetWinningOverride(item), xelib.EditorID(record), "NPC_", patchFile, locals, helpers);
						if(signature != "AMMO") {
							xelib.AddItem(record, xelib.EditorID(lvliRecord), xelib.GetValue(previousRecord, "Items\\[" + i.toString() + "]\\CNTO\\Count"));
							xelib.RemoveItem(record, xelib.GetValue(item, "Record Header\\FormID"));
						} else {
							let pAmmo = false;
							for(let j = 0; j < xelib.GetValue(record, "COCT"); j++) {
								let item = xelib.GetLinksTo(previousRecord, "Items\\[" + j.toString() + "]\\CNTO\\Item");
								if(xelib.EditorID(item) == editorID) {
									xelib.SetValue(record, "Items\\[" + j.toString() + "]\\CNTO\\Count", "1");
								}
								if(xelib.EditorID(lvliRecord) == xelib.EditorID(item)) {
									pAmmo = true;
								}
							}
							if(!pAmmo) {
								xelib.AddItem(record, xelib.EditorID(lvliRecord), (xelib.GetValue(previousRecord, "Items\\[" + i.toString() + "]\\CNTO\\Count") - 1).toString());
							}
						}
					}
				}
			}
		}, {
			//Process FLOR
			load: {
				signature: "FLOR",
				overrides: false,
				filter: function(record) {
					if(!settings.processFLORandTREE) {
						return false;
					} else if(xelib.Name(xelib.GetElementFile(xelib.GetWinningOverride(record))) == "Poverty.esp") {
						return false;
					} else if(!xelib.HasElement(record, "PFIG")) {
						return false;
					} else if(isInList(locals.blacklistFLOR, xelib.EditorID(record)) && !isInList(locals.whitelistFLOR, xelib.EditorID(record))) {
						return false;
					} else {
						return true;
					}
				}
			},
			patch: function (record, helpers, settings, locals) {
				if(settings.logCurrent) {
					helpers.logMessage(xelib.LongName(record));
				}
				let ingredient = xelib.GetLinksTo(record, "PFIG");
				let editorID = xelib.EditorID(ingredient);
				let lvliRecord = AddPovertyLVLI(patchFile, xelib.GetWinningOverride(ingredient), xelib.EditorID(record), "FLOR", patchFile, locals, helpers);
				xelib.SetLinksTo(record, lvliRecord, "PFIG");
			}
		}, {
			//Process TREE
			load: {
				signature: "TREE",
				overrides: false,
				filter: function(record) {
					if(!settings.processFLORandTREE) {
						return false;
					} else if(xelib.Name(xelib.GetElementFile(xelib.GetWinningOverride(record))) == "Poverty.esp") {
						return false;
					} else if(!xelib.HasElement(record, "PFIG")) {
						return false;
					} else if(isInList(locals.blacklistTREE, xelib.EditorID(record)) && !isInList(locals.whitelistTREE, xelib.EditorID(record))) {
						return false;
					} else {
						return true;
					}
				}
			},
			patch: function (record, helpers, settings, locals) {
				if(settings.logCurrent) {
					helpers.logMessage(xelib.LongName(record));
				}
				let ingredient = xelib.GetLinksTo(record, "PFIG");
				let editorID = xelib.EditorID(ingredient);
				let lvliRecord = AddPovertyLVLI(patchFile, xelib.GetWinningOverride(ingredient), xelib.EditorID(record), "TREE", patchFile, locals, helpers);
				xelib.SetLinksTo(record, lvliRecord, "PFIG");
			}
		}],
        finalize: function () {
        }
    })
});

function isInList(list, editorID) {
	let i;
	for(i = 0; i < list.length; i++) {
		if(editorID.substring(0, list[i].length) == list[i]) {
			return true;
		}
	}
	return false;
}

function getsReferencedByRecordWithSignature(record, signature, signature2) {
	let references = xelib.GetReferencedBy(record);
	for(let i = 0; i < references.length; i++) {
		let currentSignature = xelib.Signature(references[i]);
		if(currentSignature == signature || currentSignature == signature2) {
			return true;
		}
	}
	return false;
}

function AddPovertyLVLI(file, record, originEditorID, originSignature, patchFile, locals, helpers) {
	let signature = xelib.Signature(record);
	let editorID = xelib.EditorID(record);
	//If reference is LVLI get the first non LVLI entry
	if(signature == "LVLI" && xelib.Signature(xelib.GetLinksTo(record, "Leveled List Entries\\[0]\\LVLO\\Reference")) == "LVLI" && xelib.HasElement(xelib.GetLinksTo(record, "Leveled List Entries\\[0]\\LVLO\\Reference"), "Leveled List Entries")) {
		var innerlvli = xelib.GetWinningOverride(xelib.GetLinksTo(record, "Leveled List Entries\\[0]\\LVLO\\Reference"));
		while(xelib.Signature(innerlvli) == "LVLI" && xelib.Signature(xelib.GetLinksTo(innerlvli, "Leveled List Entries\\[0]\\LVLO\\Reference")) == "LVLI" && xelib.HasElement(xelib.GetLinksTo(record, "Leveled List Entries\\[0]\\LVLO\\Reference"), "Leveled List Entries")) {
			innerlvli = xelib.GetWinningOverride(xelib.GetLinksTo(innerlvli, "Leveled List Entries\\[0]\\LVLO\\Reference"));
		}
		signature = xelib.Signature(innerlvli);
	}
	//Special cases
	if(originSignature == "FLOR" || originSignature == "TREE" || (originSignature == "LVLI" && originEditorID.includes("YASH2_Ingredient"))) {
		editorID = editorID + "_FLORA";
	} else if(editorID.includes("Gold001") && isInList(locals.merchantGold, originEditorID)) {
		editorID = editorID + "_MERCHANT";
	} else if(editorID.includes("SpellTome") || editorID.includes("Scroll") || isInList(locals.spellBook, editorID)) {
		editorID = editorID + "_SPELL";
	} else if((originSignature == "NPC_" && "AMMO" == signature) || (originSignature == "LVLI" && (("MISC" == signature && originEditorID.includes("DeathItem") && getsReferencedByRecordWithSignature(record, "COBJ", "")) || isInList(locals.npcFood, originEditorID) || isInList(locals.npcResource, originEditorID) || isInList(locals.npcIngredient, originEditorID) || ("ALCH|INGR".includes(signature) && originEditorID.includes("DeathItem"))))) {
		editorID = editorID + "_NPC";
	}
	if(!(xelib.HasElement(patchFile, "LVLI\\p" + editorID) || xelib.HasElement(xelib.FileByName("Poverty.esp"), "LVLI\\p" + editorID))) {
		//Add LVLI record	
		let lvli = xelib.AddElement(file, "LVLI\\LVLI");
		xelib.AddElementValue(lvli, "EDID", "p" + editorID);
		xelib.SetFlag(lvli, "LVLF", "Calculate for each item in count", true);
		xelib.AddLeveledEntry(lvli, xelib.GetHexFormID(record, false, false), "1", "1");
		switch(signature) {
			case "ALCH":
				if(editorID.includes("_FLORA")) {
					xelib.AddElementValue(lvli, "LVLG", "pHarvestFoodFlora");
				} else if(editorID.includes("_NPC")) {
					xelib.AddElementValue(lvli, "LVLG", "pHarvestFoodNPC");
				} else if(xelib.HasKeyword(record, "VendorItemPotion") || xelib.HasKeyword(record, "VendorItemPoison")) {
					xelib.AddElementValue(lvli, "LVLG", "pPotion");
				} else if(xelib.HasElement(record, "ENIT\\Sound - Consume") && xelib.GetValue(record, "ENIT\\Sound - Consume") != "NULL - Null Reference [00000000]" && xelib.GetHexFormID(xelib.GetLinksTo(record, "ENIT\\Sound - Consume"), false, false) == "000B6435") {
					xelib.AddElementValue(lvli, "LVLG", "pDrink");
				} else {
					xelib.AddElementValue(lvli, "LVLG", "pFood");
				}
				break;
			case "AMMO":
				if(editorID.includes("_NPC")) {
					xelib.AddElementValue(lvli, "LVLG", "pAmmoNPC");
				} else {
					xelib.AddElementValue(lvli, "LVLG", "pAmmo");
				}
				break;
			case "ARMO":
				xelib.AddElementValue(lvli, "LVLG", "pArmor");
				break;
			case "BOOK":
				if(editorID.includes("_SPELL")) {
					xelib.AddElementValue(lvli, "LVLG", "pBookSpell");
				} else {
					xelib.AddElementValue(lvli, "LVLG", "pBook");
				}
				break;
			case "INGR":
				if(editorID.includes("_FLORA")) {
					xelib.AddElementValue(lvli, "LVLG", "pHarvestIngredientsFlora");
				} else if(editorID.includes("_NPC")) {
					xelib.AddElementValue(lvli, "LVLG", "pHarvestIngredientsNPC");
				} else {
					xelib.AddElementValue(lvli, "LVLG", "pIngredient");
				}
				break;
			case "MISC":
				if(editorID.includes("_NPC")) {
					xelib.AddElementValue(lvli, "LVLG", "pHarvestResourceNPC");
				} else if(editorID.includes("_MERCHANT")) {
					xelib.AddElementValue(lvli, "LVLG", "pMerchantGold");
				} else if(editorID.includes("Gold001")) {
					xelib.AddElementValue(lvli, "LVLG", "pGold");
				} else if(getsReferencedByRecordWithSignature(record, "COBJ", "")) {
					xelib.AddElementValue(lvli, "LVLG", "pResource");
				} else {
					xelib.AddElementValue(lvli, "LVLG", "pClutter");
				}
				break;
			case "SCRL":
				xelib.AddElementValue(lvli, "LVLG", "pBookSpell");
				break;
			case "SLGM":
				xelib.AddElementValue(lvli, "LVLG", "pSoulGem");
				break;
			case "WEAP":
				xelib.AddElementValue(lvli, "LVLG", "pWeapon");
				break;
		}
		return lvli;
	} else {
		if(xelib.HasElement(xelib.FileByName("Poverty.esp"), "LVLI\\p" + editorID)) {
			return xelib.GetElement(0, xelib.Path(xelib.FileByName("Poverty.esp")) + "\\LVLI\\p" + editorID);
		} else {
			return xelib.GetElement(0, xelib.Path(patchFile) + "\\LVLI\\p" + editorID);
		}
	}
}
