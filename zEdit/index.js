registerPatcher({
    info: info,
    gameModes: [xelib.gmTES5, xelib.gmSSE],
    settings: {
        label: 'Poverty Patcher',
        templateUrl: `${patcherUrl}/partials/settings.html`,
        defaultSettings: {
      		processREFR: true,
      		processCONT: true,
      		processFLORandTREE: true,
      		processLVLI: true,
			processNPC_: true,
			customPatch: "",
			logCurrent: true
        }
    },
    requiredFiles: ["Poverty.esp"],
	getFilesToPatch: function (filenames) {
		return filenames.filter(function(value, index, arr) {
            return (value != "Poverty.esp");
        });
    },
    execute: (patchFile, helpers, settings, locals) => ({
        initialize: function () {
			xelib.SetFileAuthor(patchFile, "evrymetul and Elscrux");
			xelib.SetFileDescription(patchFile, "All-in-One Patch for Poverty by evrymetul - Automatically generated by zEdit-Patcher by Elscrux");
			
			helpers.logMessage("Building references: This might take several minutes");
			xelib.BuildReferences(0, true);

			//--------------------------------
			// blacklist for placed objects
			// and items inside containers,
			// leveled lists and npcs
			//--------------------------------
			locals.blacklist = [
					"DefaultBookShelfBookMarker",
					"aaaBalokDunGlassClaw",
					"aaaBalokEnchDragonPriestDagger",
					"aaaWereBanditSpecialPick",
					"AKChrysamere",
					"AKCommCunosNote",
					"AKDwarven",
					"AKFa",
					"AKGnarlStaff",
					"AKIdgrodsNote",
					"AKLoversNote01",
					"AKMithril",
					"AKOfficerQuerciusNote01",
					"AKOHMoneyNote",
					"AKOwarvenGoggles",
					"AKPit",
					"AKPlayerNote",
					"AKPocketMap0",
					"AKRiftenLoversNote",
					"AKRuefulButcherNote",
					"AKSHSuicideNote01",
					"AKSixthHouseBellHammer",
					"AKSkeevertownDissectionNote01",
					"AKTeddy",
					"AKTeeth",
					"AKThiefNote01",
					"AKTohanHelmet",
					"AKWholesalersNote",
					"AKZombieAmulet",
					"AKZombieEarNecklaceRecipe01",
					"AKZombieGirlMarcusNote",
					"AKZombieHusbandNote01",
					"AleWhiterunQuest",
					"ArmorBoneCrown",
					"ArmorDaedricBootsarnima",
					"ArmorDaedricGauntletsarnima",
					"ArmorDragonPriestMaskWoodHelmet",
					"ArmorDwarvenHelmetarnima",
					"arnimaaximandletter",
					"ArnimaFlameAvatarSoulGem",
					"ArnimaGuardianAvatarSoulGem",
					"ArnimaHolyAvatarSoulGem",
					"arnimabelmorjournal",
					"arnimabelmornote",
					"ArnimaBlackBook",
					"arnimabook1",
					"arnimadarkburdenbook",
					"arnimadragonclaw",
					"arnimajournal",
					"ArnimaManifestSupremacyTome",
					"arnimaMaximandletter",
					"ArnimaNoteMQ9",
					"arnimaperyitecultist",
					"arnimarandomnote",
					"ArnimaReaverAvatarSoulGem",
					"ArnimaSpellMace",
					"ArnimaSpellShield",
					"ArnimaSpellTomeDarkCircle",
					"ArnimaStealthAvatarSoulGem",
					"arnimatemplenote1",
					"ArnimaUnHolyAvatarSoulGem",
					"arnimavoidthought",
					"BalokBookRedguardHistory",
					"BalokDisplayRoomBook",
					"BalokHuntingBow",
					"BalokSraadomaarJournal",
					"BalokStaadonaarJournal", 
					"BalokStartUoBook",
					"BalokSteelSword",
					"BasketCarry",
					"BoneHumanSkullFullArnima",
					"bp2garden",
					"bp2skoomanote",
					"bp2wanted1",
					"BYOHHouseGuide",
					"C04HagravenHead",
					"CasSecEntranceCrest",
					"CivilWarMapFlag01",
					"CoSCloakAshlander",
					"CoSCloakCrow",
					"CoSCloakDaedric",
					"CoSCloakDawnguard",
					"CoSCloakDragonPriest",
					"CoSCloakDwemerCeremonial",
					"CoSCloakFallWinterhold",
					"CoSCloakGreyFox",
					"CoSCloakHimirHide",
					"CoSCloakHjarvoBlanket",
					"CoSCloakHuntersFolly",
					"CoSCloakKvatch",
					"CoSCloakNorthPaladin",
					"CoSCloakNya",
					"CoSCloakScale",
					"CoSCloakShortBlackTalos",
					"CoSCloakShortDawnguard",
					"CoSCloakShortLover",
					"CoSCloakShortRedEagle",
					"CoSCloakVaermina",
					"CoSCloakWarmSands",
					"CoSCloakWildHunt",
					"CR12TotemsOfHircine",
					"CWArrow",
					"CWDummy",
					"CWFort",
					"CWIABCBarbarians",
					"CWIDissolution",
					"CWIEdictBeinaarkhNew",
					"CWIEntryExamination",
					"CWIMagickaMeteor",
					"CWIMGBootsArchmage",
					"CWIMiddenBarracksJournal",
					"CWIMiddenTempleJournalNew",
					"CWINecromancersMoon",
					"CWINelothSergiusNote",
					"CWINiryaNote",
					"CWIOrbsOfWinterhold",
					"CWIRepresentingTime",
					"CWIRunsDoll",
					"CWISealBeinaarkhNew",
					"CWISkoomaBook",
					"CWISkyrimChart",
					"CWISoulsPraxography",
					"CWIStroti",
					"CWITeleportSpellTome",
					"CWITF",
					"CWIWRCanopicJarNew",
					"CWIXU",
					"DA01",
					"DA03RuefulAxe",
					"DA04",
					"DA06Volendrung",
					"DA07",
					"DA08EbonyBlade",
					"DA13Afflicted",
					"DA14SamNote",
					"DA14SanguineRose",
					"DA14Water",
					"DA16SkullofCorruption",
					"DA16Torpor",
					"DaedricGreatswordarnima",
					"DancersFlute",
					"DB003TovaLetter",
					"DB01AventusLetter",
					"DB05ElvenBow",
					"DB06Schedule",
					"DB07Journal",
					"DBArmorGlovesReward",
					"DBBladeOfWoeReward",
					"DBCiceroJournal",
					"direnni",
					"DLC01DrawKnife",
					"DLC01DweSchematics",
					"DLC1ElderScrollBack",
					"DLC01SoulCairnReaperFragment",
					"DLC01TortureTool01",
					"DLC1BoneHawk",
					"DLC1Book3Valuable",
					"DLC1DarkfallPassageNote",
					"DLC1DawnguardRune",
					"DLC1dunRedwaterDenJournal",
					"DLC1FVBook02English",
					"DLC1IvoryCrown",
					"DLC1LD_Aetheri",
					"DLC1LD_Katria",
					"DLC1nVampireNightPowerNecklaceBats",
					"DLC1RecipeFrenzy1",
					"DLC1RuunvaldJournal",
					"DLC1SoulCairnRJPOI2Note",
					"DLC1SpellTomeConjure",
					"DLC1VQ07InitiatesEwer",
					"DLC1V",
					"DLC2Bl",
					"DLC2dunBloodskalNote01",
					"DLC2dunFahlbtharzDwarvenHelmet",
					"DLC2dunHaknirScimitar01",
					"DLC2dunKarstaagSkullItemNoName",
					"DLC2dunKolbjornBoots",
					"DLC2dunKolbjornGauntlets",
					"DLC2dunKolbjornHelm",
					"DLC2dunKolbjornMinersNote",
					"DLC2dunKolbjornSkull",
					"DLC2dunKolbjornRalisJournal",
					"DLC2dunKolbjornRing",
					"DLC2dunNchardakCube",
					"DLC2DweKagrumezControlGemInv01",
					"DLC2ExpSpiderExperimentJournal",
					"DLC2FrostmothLetter04",
					"DLC2Hork",
					"DLC2Hrodulf",
					"DLC2IldariJournal",
					"DLC2KagrumezFateBow01",
					"dlc2MerchNote",
					"DLC2POIUshaNote01",
					"DLC2RR",
					"DLC2TG",
					"DLC2TT2HeartStone",
					"Dragon_Green_BloodHeadFXArmor",
					"DremoraRobesBlackPlayable",
					"Dummy",
					"dunAbandonedPrisonNote",
					"dunAlftandDwemerStudy01",
					"dunAlftandEndrastsJournal01",
					"dunAlftandJ",
					"dunAlftandManifestJournal01",
					"dunAn",
					"dunBloatedMan",
					"dunBrokenOarHargarJournal",
					"dunC",
					"dunD",
					"dunEmbershardTatteredJournal",
					"dunF",
					"dunG",
					"dunHa",
					"DunHillgrundsTombValsVeransLetter",
					"dunHuntersBow",
					"dunIlinaltasDeepAdventurerJournal",
					"dunIronbindLetter",
					"dunK",
					"dunLabyrinthian",
					"DunLabyrinthianSpellTomeEquilibrium",
					"dunLiarsRetreatLonghammer",
					"dunLost",
					"dunMarkarthWizard_LabJournal",
					"dunMarkarthWizardSpiderControlStaff",
					"dunMidden",
					"dunMistwatch",
					"dunMovarthsBoots",
					"dunMzinchaleft",
					"dunN",
					"dunOrotheimJournal",
					"dunP",
					"DunP",
					"DUNPOIDragonAttackNote",
					"dunR",
					"dunSaarthalStaffJyrikStaff",
					"dunSerpentsBluffNote",
					"dunShipwreck04TriusNote",
					"dunSilentMoonsLunarBook",
					"dunSteamcragCampNote",
					"dunT",
					"dunU",
					"dunV",
					"dunW",
					"dunYng",
					"DunYngolBarrowSteelPlateHelmet",
					"DwarvenWarhammerarnima",
					"DwaSpAndavelRing",
					"DwaSpArm01Cuirass",
					"DwaSpArm02CuirassSpecial",
					"DwaSpBeeStatue",
					"DwaSpBookABCsForBarbarians",
					"DwaSpBookFellowshipOfTheTemple",
					"DwaSpBookHolidaysOfTheIliacBay",
					"DwaSpBookMarasTear",
					"DwaSpChess",
					"DwaSpDSQ",
					"DwaSpHumanSkullSpecial",
					"DwaSpJournal01",
					"DwaSpMusicCube",
					"DwaSpRing01",
					"DwaSpSakeNote",
					"DwaSpSaKeNote",
					"DwaSpShanatNote",
					"DwaSpSnippyControlItem",
					"DwaSpStaff",
					"EnchArmorDraugrHelmetResistFire03",
					"EnchCircletWaterbreathing",
					"EnchDraugrGreatswordHonedFire03",
					"EnchRingTwoHanded05arnima",
					"EnchSteelBattleaxeFierySouls",
					"ExecutionerAxearnima",
					"Favor",
					"FF",
					"FirebrandWine",
					"Freeform",
					"FSArmorReinforcedGuard",
					"FSArmorStaalgarde",
					"FSBjarrikWaterbreathing",
					"FSdun",
					"FSMQ0",
					"FSPlayerHomeLodgeLetter",
					"FSSkullCrusher",
					"FSSpellTomeO",
					"FSSQ",
					"FSTest",
					"FSVanvirsMasterpiece",
					"FXdustDropMedWEP",
					"highGateRuinsScroll",
					"HumanFlesharnima",
					"ImperialWarHorn",
					"IronSwordBrokenHandle",
					"IronWarAxeBroken",
					"JSwordsCorundumBlade",
					"JSwordsDovahLuv",
					"JSwordsDragonbrand",
					"JSwordsGungnir",
					"JSwordsJadeBlade",
					"JSwordsMeanSword",
					"Letter",
					"manny_GF_Amulet_",
					"manny_GF_Armor_",
					"manny_GF_Book_ForgottenDraugr",
					"manny_GF_book_Ocato",
					"manny_GF_DwarvenPraetorianDynamo",
					"manny_GF_FakeGemDiamondFlawless",
					"manny_GF_Journal_UmbranoxJournal06",
					"manny_GF_Potion_DuneripperBlood",
					"manny_GF_SpellTome_AncientVision",
					"manny_GF_Stone",
					"manny_GF_Weapon_BladesSword",
					"manny_GF_Weapon_Ocato",
					"Markarth",
					"MASBalRanJournal",
					"MASBlackHandsDagger",
					"MASChrysamere",
					"MASCourierLetter",
					"MASDoranaHammer",
					"MASFinalTrial",
					"MASFirstQuestion",
					"MASKagrenacHeart",
					"MASKagrenarBook",
					"MASKeeningReplica",
					"MASKillRing",
					"MASMandynMT",
					"MASMTCongrats",
					"MASSecondQuestion",
					"MASSunderReplica",
					"MASThirdQuestion",
					"MASThreeDog",
					"MASWraithguardReplica",
					"MG03Book",
					"MGRArniel04SoulGem",
					"MGRDestruction",
					"MGRitual02Book",
					"MGRKeening",
					"mjb_Book",
					"mjb_DarkwaterCrossingNote01",
					"mjb_DawnstarQ01Journal",
					"mjb_RoriksteadNote",
					"mjb_RoriksteadQ01Journal",
					"MQ103FarengarBook",
					"MQ105Note",
					"MQ106DragonParchment",
					"MQ203AkaviriKatana5",
					"MQPaarthurnaxBook",
					"MS",
					"NecroAntiochJournal",
					"NecroArkayPriestHeart",
					"NecroBlackBook01",
					"NecroBlackDye",
					"NecroBloodroot",
					"NecroCaravanAttackOrders01",
					"NecroConstructSkeletonNote01",
					"NecroGreenDye",
					"NecroJournal01",
					"NecroLichJournal",
					"NecroLichSpellKey",
					"NecroQuest04AlchemistNote",
					"NecroScourgBarrowBook01",
					"NecroScourgBarrowMinionJournal",
					"NecroSewerLaboratoryUpgrade",
					"NecroTomeofUnlife",
					"NecroTowerLaboratoryUpgrade",
					"NecroVigilantLetter01",
					"NecroVyngaldShroud",
					"NN01SinderionsJournal",
					"POI",
					"REQ_Book_Alchemy_ZerusChaosWizards",
					"REQ_Book_BelethorHowToSellYourSister",
					"REQ_Book_FellglowFailureNote",
					"REQ_Book_GorakNote",
					"REQ_Book_HelgenEasterEgg",
					"REQ_Book_HowNotToBeSeen",
					"REQ_Book_Jo",
					"REQ_Book_LetterMercerFreyHouse",
					"REQ_Book_LetterToRon",
					"REQ_Book_MQ",
					"REQ_Book_SaarthalSuppliesNote",
					"REQ_Book_Speech_",
					"REQ_Book_TalesOfHalfdanTheBlack",
					"REQ_Book_TheArtOfFishingAndSlapping",
					"REQ_Book_TheDarkKnightsStory",
					"REQ_Book_TheNaughtyAlchemist",
					"REQ_Book_TheThirteenthStone",
					"REQ_Book_TyranusJournal",
					"REQ_Book_ValtheimBossJournal",
					"REQ_Daedric",
					"sc_ArvakSkullUNIQUE",
					"SkinDragonPriestFXMist",
					"SolitudeToryggWarHorn",
					"SpellTomearnimaFlayingBolt",
					"SpellTomearnimaPoxBarrage",
					"SpellTomearnimaSpite",
					"SpellTomeConjureDaedrothNew",
					"SpellTomeConjureScampNew",
					"SpellTomeConstructSkeleton",
					"SpellTomeDecay",
					"SpellTomeEnervate",
					"SpellTomeMassReanimate",
					"SpellTomeTransmuteOreMineral",
					"SovRoastOx",
					"SteelBattleAxeBroken",
					"SteelWarhammerBrokenHandle",
					"T0",
					"TG00MadesiRing",
					"TG01HaelgaStatue",
					"TG02BillofSale",
					"TG03SabjornLetter",
					"TG04",
					"TG05GallusJournalPre",
					"TG07Chillrend001",
					"TG07MercersPlans",
					"TG08SkeletonKey",
					"TGBook0NightingalesVolume",
					"TGCrown",
					"TGFenceCaravanSatchel",
					"TGLT",
					"TGTQ",
					"TGRFOValueItem",
					"TGRGeneralValueItem",
					"TGTQ03SolitudeLetter",
					"TrapDweBallistaBoltAmmo01",
					"Windhelm",
					"WTAdventurersJournal",
					"WTAlberthorJournal",
					"WTAmarthNote",
					"WTAndurilJournal",
					"WTArmorWagonShield",
					"WTBandit",
					"WTBazrob",
					"WTBehnNote",
					"WTBladedBroom",
					"WTBlindRobbersNote",
					"WTBloodletterDagger",
					"WTBounty",
					"WTChaoswielder",
					"WTClawNote",
					"WTCurpurseCrevasseNote",
					"WTDBSanctuary",
					"WTDockmasterJournal",
					"WTDonnarJournal",
					"WTDunyick",
					"WTDustyJournal",
					"WTElmeraBook",
					"WTFjeimirsNote",
					"WTGoredusterBase",
					"WTGronndalLetter",
					"WTHaetarsNote",
					"WTHermanAdventurerNote",
					"WTLetter",
					"WTLurius",
					"WTMarauder",
					"WTMinerJournal",
					"WTMoonwatchBanditNote",
					"WTNecromancerNote",
					"WTOlgaNote",
					"WTPrisonThalmorNote",
					"WTRamblingJournal",
					"WTRedPhantomNote",
					"WTRustedClaw",
					"WTSaegloporNote",
					"WTSeveredLeg",
					"WTSpellmakersLetter",
					"WTSpellTomeCallOfThe",
					"WTSpellTomeConjureDraugr",
					"WTSpellTomeConjureMudcrab",
					"WTStaff",
					"WTThalmor",
					"WTTobusTurnicusNote",
					"WTVampireJournal",
					"WTVorkJournal",
					"WTVulom",
					"WTWarlockNote",
					"WTWarningNote",
					"YsgramorsBladePiece07",
					"zzzAoMBladeMercyEbony",
					"zzzAoMBrokenEyeofMadness",
					"zzzAoMDiary",
					"zzzAoMLetter0",
					"zzzAoMMolagSwordRusty",
					"zzzAoMPieceOfBal0",
					"zzzAoMWitchDoll01",
					"zzzBMAncientfishermanAmulet",
					"zzzBMAredhelNote",
					"zzzBMJoshuaNote",
					"zzzBMStendarrDagger",
					"zzzCHAdabal",
					"zzzCHAkatoshGreatsword",
					"zzzCHAltanoSkull",
					"zzzCHAriaNote",
					"zzzCHArmorAlessianKnightHelmet",
					"zzzCHArmorBloodSuckerMaskKing",
					"zzzCHArmorKeeperHelmet",
					"zzzCHArmorLaza",
					"zzzCHArmorOrderShield4",
					"zzzCHArmorPelinal",
					"zzzCHArmorSelective",
					"zzzCHArmorShellHelmet",
					"zzzCHArmorTower",
					"zzzCHArmorUmaril",
					"zzzCHAtimaPelt",
					"zzzCHBalConjure",
					"zzzCHBerichNote",
					"zzzCHCatRingG",
					"zzzCHChariotLance",
					"zzzCHClothesApprentice",
					"zzzCHClothGuardianEgg",
					"zzzCHClothJhunalRune",
					"zzzCHClothOrderBeacon",
					"zzzCHClutchRing",
					"zzzCHCryRing",
					"zzzCHDaedricSythe",
					"zzzCHDarkSlayer",
					"zzzCHElementalRing",
					"zzzCHElvenGiantSword",
					"zzzCHExselector1H",
					"zzzCHEyeOfMarukh",
					"zzzCHEyeRing",
					"zzzCHGorieusSwordPlayable",
					"zzzCHGregoryNote0",
					"zzzCHKynarethSpear",
					"zzzCHMara",
					"zzzCHMenelionNote",
					"zzzCHMeridiaConjureUmaril",
					"zzzCHMoonlightSword",
					"zzzCHMorihausSword",
					"zzzCHOrderConjure",
					"zzzCHOrderGiantswordPlayable",
					"zzzCHOrderSword2",
					"zzzCHPaladinSpear",
					"zzzCHPopeStaffGold",
					"zzzCHPotionMolagHeart",
					"zzzCHRegenRing",
					"zzzCHRelicPotionIncMagicka",
					"zzzCHRelicPotionIncStamina",
					"zzzCHRenaldSwordPlayable",
					"zzzCHRuneRing",
					"zzzCHSelectorNote",
					"zzzCHShoggothSword",
					"zzzCHSlaverNote0",
					"zzzCHSpellTomeConjureBoulor",
					"zzzCHSpiderRapier",
					"zzzCHTowerSpear1H",
					"zzzCHTubalHammer",
					"zzzCHUmarilSwordPlayable",
					"zzzCOCorpseClubPlayable",
					"zzzCODiaryBartholo",
					"zzzCODiaryJulia",
					"zzzCODiaryMarcus",
					"zzzCOLetterJuliaToMarcus",
					"zzzCOLetterLamthorTo",
					"zzzCOLetterMaidToBal",
					"zzzCOMarcusNote",
					"zzzCOMzaqNote0",
					"zzzCONoteJulius",
					"zzzCOSummilNote",
					"_Lull_Archerons",
					"_Lull_AtlantanPneuma",
					"_Lull_Bear",
					"_Lull_Book10",
					"_Lull_Book11",
					"_Lull_Book2",
					"_Lull_Book3",
					"_Lull_Book6",
					"_Lull_Cave_Battery",
					"_Lull_Cave_Drill",
					"_lull_cheaterMessage",
					"_lull_divingHelmet",
					"_Lull_GateAddress",
					"_lull_gem",
					"_Lull_IdiotsLantern",
					"_Lull_MemodermicSword",
					"_Lull_Shotmold",
					"_Lull_Stone"
			]
			
			//--------------------------------
			// whitelist for placed objects
			// and items inside containers,
			// leveled lists and npcs
			//--------------------------------
			locals.whitelist = [
				"zzzCHArmorUmarilCuirass_Valkyrie",
				"zzzCHArmorUmarilHelmet_Frog"
			]

			//--------------------------------
			// blacklist for containers
			//--------------------------------
			locals.blacklistCONT = [
				"ArnimaArmorContainerResource",
				"ArnimaSpellContainerResource",
				"BalokTest",
				"CCF_AllClothing",
				"CWI_Container_All",
				"DEMO",
				"DLC01QA",
				"DLC02QA",
				"DLC2dunFrostmoonVendorChest",
				"DLC2MaximianPack",
				"e3DEMO",
				"E3Demo",
				"HaemProjects",
				"MASSelyseTestChest",
				"MQ101BarracksChest02",
				"MQ201ElenwenOfficeChest",
				"QA",
				"SkyHavenArmoryChest",
				"zzzCHTESTArmorChest"
			]
			
			//--------------------------------
			// whitelist for containers
			//--------------------------------
			locals.whitelistCONT = [
				
			]

			//--------------------------------
			// blacklist for flora records
			//--------------------------------
			locals.blacklistFLOR = [
				"CoinPurse",
				"BYOHMead",
				"TGCoinPurse"
			]
			
			//--------------------------------
			// whitelist for flora records
			//--------------------------------
			locals.whitelistFLOR = [

			]

			//--------------------------------
			// blacklist for leveled lists
			//--------------------------------
			locals.blacklistLVLI = [
					"1Dr_BANDG_FlaskCCO",
					"1Dr_BANDG_NotebookCCO",
					"1nivListCloakGuardHoodARM",
					"1nivSublistCloak",
					"1nivSublistHelm",
					"1nivSublistHoodCommon",
					"ArmorCompanionsSet",
					"ArmorElvenSet",
					"ArmorGlassSet",
					"ArmorHideSet",
					"ArmorImperialHeavyHelmets",
					"ArmorImperialHeavySet",
					"ArmorImperialLightSet",
					"ArmorImperialStuddedSet",
					"ArmorIronSet",
					"ArmorLeatherSet",
					"ArmorOrcSet",
					"ArmorReachHelmet",
					"ArmorScaledSet",
					"ArmorStormcloakBearSet",
					"ArmorStormcloakHelmets",
					"ArmorStormcloakSet",
					"ArmorStuddedSet",
					"BYOHHouseTestItems",
					"CCO_NewItems_",
					"CCO_NewRings",
					"ClothesFarm",
					"CORE_CraftingItems",
					"CoSSublistCloaks",
					"CW01BPlayerHelpItems",
					"CWBearArmorPlayerReward",
					"CWCourierDocuments",
					"CWFinaleFactionLeaderSwordList",
					"CWPlayerUniform",
					"CWRankReward",
					"CWSoldierImperialGear",
					"CWSoldierSonsGear",
					"CWSoldierWoundedOutfit",
					"DA03AxeDeathItem",
					"DA09DawnbreakerList",
					"DA14RingDeathItem",
					"DA14StaffDeathItem",
					"DB02ShackKey",
					"DB08DeathBook",
					"DeathContainerList",
					"DeathItemDwarvenSphere",
					"DLC1DawnGuardHelmet75",
					"DLC1FalmerShamanWeapon",
					"DLC1LItemDawnguard",
					"DLC1LItemDisguisedHunterInventory",
					"DLC1LItemFalmer",
					"DLC1LItemKeeper",
					"DLC1LitemStaffFalmer",
					"DLC1LItemStaffFalmer",
					"DLC1LItemVampireCuirass",
					"DLC1LItemWeaponDawnguardCrossbowLoot75Gated",
					"DLC1LItemWeaponFalmerShaman",
					"DLC1RV03HunterArmor",
					"DLC1RV05RemainsList",
					"DLC1SublistEnchCrossbow",
					"DLC1SublistEnchDwarvenCrossbow",
					"DLC1SublistEnchVampireRobes",
					"DLC1SublistKeeper",
					"DLC1SublistStaffDestructionFalmer",
					"DLC1WrathmanSummonedWeapon2H",
					"DLC2Bonemold",
					"DLC2Chitin",
					"DLC2dunHaknirGhostLeveledList",
					"DLC2dunKolbjornLItemMinerClothes",
					"DLC2ExpSpiderAlbinoDeathItemButt",
					"DLC2LItemDraugrHulkingShield67",
					"DLC2LItemIldariRobesDestruction",
					"DLC2LItemIngredientFoodPrepared",
					"DLC2LItemSpellTomes",
					"DLC2LItemSpellTOmes",
					"DLC2LitemSpellTomes",
					"DLC2LItemWeaponBattleAxeDremora",
					"DLC2LItemWeaponBowDremora",
					"DLC2LItemWeaponDaggerDremora",
					"DLC2LItemWeaponGreatSwordDremora",
					"DLC2LItemWeaponMaceDremora",
					"DLC2LItemWeaponSwordDremora",
					"DLC2LItemWeaponWarAxeDremora",
					"DLC2LItemWeaponWarhammerDremora",
					"DLC2LootRieklingSpears50",
					"DLC2MerilarRendasDeathItem",
					"DLC2MQ06Miraak",
					"DLC2NordicHeavyBoss",
					"DLC2NordicShield20",
					"DLC2OutfitSkaalHatChance50",
					"DLC2SpellBook",
					"DLC2Stalhrim",
					"DLC2SublistEnchArmor",
					"DLC2SublistEnchNordic",
					"DLC2SublistEnchStahlrim",
					"DLC2SublistEnchStalhrim",
					"dunHillgrundsTombRewardList",
					"dunLItemFolgunthurMikrulSword",
					"dunLItemFrostmereBlade",
					"dunLItemGeirmundSigdisBow",
					"dunMarkarthWizardMeleeSecurity",
					"dunSilentMoonsLItemEnch",
					"FSLItemIngotAny",
					"FSLItemPelt",
					"FSLItemWeaponTownsfolkBorvald80",
					"FSMQ08LItem08SoldierGoodWeaponAny",
					"GuardGear",
					"HunterHatChance50_CCF",
					"JSwords",
					"LItemArmor",
					"LitemArmorShieldHeavyTown",
					"LItemBandit",
					"LItemBlacksmithMinDagger",
					"LItemClothesFarm",
					"LItemDA13Armor",
					"LItemDawnguard",
					"LItemDLC2ClothesDarkElfBlue",
					"LItemDLC2ClothesDarkElfBrn",
					"LItemDLC2ClothesDarkElfRed",
					"LItemDragonPriestStaff100",
					"LItemDraugr0",
					"LItemDraugrEbonyShield50",
					"LItemDraugrShield100",
					"LItemDraugrShield50",
					"LItemDraugrSword",
					"LItemEnchHoodMagickaRate_Black_CCF",
					"LItemEnchImperialSword",
					"LItemEnchNecromancerRobes",
					"LItemEnchOrcishBattleaxe",
					"LItemEnchSkullPendant",
					"LItemFalmerWeapon",
					"LItemForsworn",
					"LItemGutterSaint",
					"LItemHoodsBlueWhite_CCF",
					"LItemHoodsRedOrange_CCF",
					"LItemHunterWeaponBow",
					"LItemIngotGold50",
					"LItemIngredientUncommonSame75",
					"LItemIronOrSteel",
					"LitemJunk",
					"LItemMaceForOrcs",
					"LItemMS09",
					"LItemOrcStronghold",
					"LItemOre",
					"LItemPenitusWeapon1H",
					"LItemReligiousSymbols",
					"LItemScroll",
					"LItemSilverHandWeapon",
					"LItemSpellTomes",
					"LitemSpellTomes",
					"LItemSpellTOmes",
					"LItemSoldierImperialArmorSet",
					"LItemSoldierSonsArmorSet",
					"LItemSoldierSonsBattleaxe",
					"LItemSoldierSonsGreatsword",
					"LItemSoldierSonsMace",
					"LItemSoldierSonsSword",
					"LItemSoldierSonsWaraxe",
					"LItemSoldierSonsWarhammer",
					"LItemSoldierSonsWeapon",
					"LItemStaffAlteration",
					"LItemStaffConjuration",
					"LItemStaffDestruction00",
					"LItemStaffDestruction25",
					"LItemStaffDestruction50",
					"LItemStaffDestruction75",
					"LItemStaffIllusion",
					"LItemStaffRestoration",
					"LItemSummersetShadowsArmor",
					"LItemTGAmuletofArticulation",
					"LItemThalmorDagger",
					"LItemThalmorShield",
					"LItemVampire",
					"LItemVigilantHeavy",
					"LItemVigilantHood",
					"LItemVigilantRobes",
					"LItemWarlockDagger",
					"LITemWarlockRobes",
					"LItemWeaponBattleAxe",
					"LItemWeaponBow",
					"LItemWeaponDagger",
					"LItemWeaponDwarven",
					"LItemWeaponGreatSword",
					"LItemWeaponMace",
					"LItemWeaponNightingale",
					"LItemWeaponSailor",
					"LItemWeaponSword",
					"LItemWeaponWarAxe",
					"LItemWeaponWarhammer",
					"LItemWEBattlemage",
					"LItemWerewolf",
					"LItemwerewolfBossWarhammer",
					"LItemWESpellsword",
					"LItemWEThief",
					"LootBanditArmor100",
					"LootGoldChangeUrns",
					"LootSabrecatBodyParts",
					"LootStaffsNecromancy100",
					"MG04RewardLVL",
					"MGR01ItemList",
					"MGR2",
					"MGRitual",
					"MQ203AkaviriKatana",
					"MQ304TsunBattleAxe",
					"MS09Reward",
					"OutfitList",
					"PenitusGear",
					"PrisonerPants50",
					"RegionalHunterBoots",
					"RegionalHunterClothes",
					"RegionalHunterGloves",
					"RegionalVigilantHood",
					"REQ_LI_Armor_",
					"REQ_LI_Dwarven_Longsword_Quality",
					"REQ_LI_Gear_Penitus",
					"REQ_LI_HealingTomeReward",
					"REQ_LI_MQ102Reward",
					"REQ_LI_OrcishArmorReward",
					"REQ_LI_RewardArmor",
					"REQ_LI_Soulcairn_Draugr02Weapon1H",
					"REQ_LI_RewardWeapon",
					"REQ_LI_VampireBoss_WeaponEbony",
					"REQ_LI_VigilantCrossbow",
					"REQ_LI_VigilantWeapon",
					"REQ_LI_Weapon",
					"REQ_NULL_SublistThalmorBowAndArrowsSteel",
					"SublistArmor",
					"SublistEnch",
					"SublistENchDaedricWarAxeAbsorb",
					"SublistScaledCuirassVariants",
					"SublistThalmor",
					"SublistWeapon",
					"TG02MercLItem",
					"TG07Chillrend",
					"TGLvlItemNightingale",
					"TGPotionof",
					"TGRewardPotion",
					"TGTQ04DeathItem",
					"UDGPDLC1SublistEnchVampireRobesMagickaRate",
					"USKPVigilantsWeaponMace",
					"USLEEPStormfang",
					"USLEEPSublistEnchDaedricBattle",
					"VendorEorlundSkyforgeSteelSet",
					"WE17BanditOutfitList",
					"zzzAoMDeathItemReyda",
					"zzzAoMOwlAccessoryFULL",
					"zzzAoMOwlAmmoALL",
					"zzzAoMOwlArmorFULL0",
					"zzzAoMOwlClothFULL",
					"zzzAoMOwlRingFULL",
					"zzzAoMOwlSpellBookALL",
					"zzzAoMOwlWeaponALL",
					"zzzBMArmorStormcloakSet",
					"zzzBMArmorWizardSet",
					"zzzCHDeathItemAuroranGuardian0",
					"zzzCHDeathItemAuroranValkyrie",
					"zzzCHDeathItemBartholo",
					"zzzCHDeathItemGreatBegger",
					"zzzCHDeathItemMentaNa",
					"zzzCHDeathItemMeridiaFollower",
					"zzzCHLitemAlessianWeapon",
					"zzzCHLitemAuroranWeapons2H",
					"zzzCHLitemDremoraWeapons",
					"zzzCHLitemEbonyArcher",
					"zzzCHLitemEbonyGiantWeapon",
					"zzzCHLitemEbonyShield",
					"zzzCHLitemOrderShield",
					"zzzCHLitemOrderWeapons",
					"zzzCHLitemScampWeapon",
					"zzzCOLitemRustyWeapons",
			]
			
			//--------------------------------
			// whitelist for leveled lists
			//--------------------------------
			locals.whitelistLVLI = [
				"LItemArmorBootsHeavyBlacksmith",
				"LItemArmorBootsHeavySpecial",
				"LitemArmorBootsLightBlacksmith",
				"LItemArmorBootsLightSpecial",
				"LItemArmorCuirassHeavyBlacksmith",
				"LItemArmorCuirassHeavySpecial",
				"LItemArmorCuirassLightBlacksmith",
				"LItemArmorCuirassLightSpecial",
				"LItemArmorDwarvenCuirassHeavy",
				"LItemArmorDwarvenGauntletsHeavy",
				"LItemArmorDwarvenHelmetHeavy",
				"LItemArmorGauntletsHeavyBlacksmith",
				"LItemArmorGauntletsHeavySpecial",
				"LItemArmorGauntletsLightBlacksmith",
				"LItemArmorGauntletsLightSpecial",
				"LItemArmorHelmetHeavyBest",
				"LItemArmorHelmetHeavyBlacksmith",
				"LItemArmorHelmetHeavySpecial",
				"LItemArmorHelmetLightBest",
				"LItemArmorHelmetLightBlacksmith",
				"LItemArmorHelmetLightSpecial",
				"LitemArmorShieldHeavyBlacksmith",
				"LItemArmorShieldHeavySpecial",
				"LItemArmorShieldLightBest",
				"LItemArmorShieldLightBlacksmith",
				"LItemArmorShieldLightSpecial",
				"LItemBanditHideHelmetVariants",
				"LItemClothesFarmAll",
				"LItemForswornBossHelmet",
				"LItemForswornMace",
				"LItemForswornSword",
				"LItemForswornWarAxe",
				"LItemForswornWeaponArrows",
				"LItemOrcStrongholdGreatsword",
				"LItemVampireWeaponBow",
				"LItemWeaponBattleAxeBlacksmith",
				"LItemWeaponBowBlacksmith",
				"LItemWeaponDaggerBlacksmith",
				"LItemWeaponGreatSwordBlacksmith",
				"LItemWeaponMaceBlacksmith",
				"LItemWeaponSwordBlacksmith",
				"LItemWeaponWarAxeBlacksmith",
				"LItemWeaponWarhammerBlacksmith"
			]

			//--------------------------------
			// blacklist for npcs
			//--------------------------------
			locals.blacklistNPC = [
					"CWBattleTullius",
					"CWFieldCOSons",
					"CWSiege",
					"DBTreasCorpseSkeleton",
					"dunBleakFallsCorpseBretonThomas",
					"dunHonningbrewRatGuy",
					"dunMarkarthWizard_Guard",
					"DLC1dunDarkfallTreasCorpse01",
					"DLC1HunterBaseIntroVigilant",
					"DLC1VQ01VigilantTolanCorpse",
					"DLC2dunFahlbtharzExplorerCorpse",
					"DLC2dunGyldenhulAdventurer",
					"DLC2EncHunterNordM",
					"DLC2KagrumezBanditBoss",
					"DLC2MerilarRendas",
					"DLC2PillarRRGuard",
					"DLC2RR",
					"DLC2ServosRendas",
					"DLC2WE05Wizard",
					"dunCGImperialSoldierArcherA04",
					"dunPOIVolcanicLuckyLorenze",
					"e3DemoArvel",
					"E3DemoTowerBanditMissile",
					"EncForsworn",
					"EncHunter",
					"EncVigilantOfStendarr",
					"GaiusMaro",
					"Golldir",
					"Jdatharr",
					"MQ206Gormlaith",
					"MQ304Froki",
					"MS03ChaletGuardExterior",
					"Player",
					"SummonGormlaith",
					"TG08BTreasCorpseThiefNordMaleOld",
					"TG09TreasCorpseAnders",
					"TreasCorpseVigilantOfStendarrMale",
					"Urwa",
					"WEAdventurerBrawler"
			]
		
			//--------------------------------
			// whitelist for npcs
			//--------------------------------
			locals.whitelistNPC = [
				
			]

			//--------------------------------
			// blacklist for references
			//--------------------------------
			locals.blacklistREFR = [
				"CWDummy",
				"DA16AwakeBarrierGem",
				"DBMarkarthDagger",
				"Favor",
				"FestivalSpicedWineSpigotRef",
				"SiddgeirBlackBriarMeadREF",
				"YsoldaFavorItemREF"
			]
			
			//--------------------------------
			// whitelist for references
			//--------------------------------
			locals.whitelistREFR = [
				
			]

			//--------------------------------
			// blacklist for tree records
			//--------------------------------
			locals.blacklistTREE = [
				"BYOHHouseFlora",
				"BYOHHouseIngrd",
				"DLC01AncestorsGladeTree"
			]
		
			//--------------------------------
			// whitelist for tree records
			//--------------------------------
			locals.whitelistTREE = [
				
			]

			//--------------------------------
			// list for records where gold
			// should be treated as merchants
			// gold
			//--------------------------------
			locals.merchantGold = [
				"Merchant",
				"Vendor",
				"PerkInvestorStoreUpgrade",
				"PerkMasterTraderGold",
				"KRY_Variable01Gold",
				"KRY_Variable02Gold",
				"KRY_Variable03Gold"
			]

			//--------------------------------
			// list for leveled lists that
			// contain death items of
			// creatures or animals
			//--------------------------------
			locals.npcItems = [
				"CreatureMeat",
				"CreatureIngr",
				"CreaturePerkIngr",
				"manny_GF_LI_AncestralCheetah",
				"manny_GF_LI_DesertWolf",
				"REQ_LI_DeathItem_Werewolf",
				"REQ_LI_Perl",
				"REQ_LI_SpiderEggs0",
				"_DS_DeathItem_",
				"_DS_LI_Mats_"
				
			]

			//--------------------------------
			// list for npcs that
			// contain death items of
			// creatures or animals
			//--------------------------------
			locals.deadItemNPCs = [
				
			]

			//--------------------------------
			// list for leveled lists that
			// contain harvestable 
			// or consumables of plants
			//--------------------------------
			locals.floraItems = [
				"REQ_LI_ClamPearl",
				"_DS_LI_Forage_",
				"YASH2_Ingredient"
			]

			//--------------------------------
			// list for records that are
			// considered a spell book
			//--------------------------------
			locals.spellBook = [
				"arnimabloodhexbook",
				"arnimaburst",
				"arnimadarkburdenbook",
				"ArnimaFrigid",
				"ArnimaGoldBoltTome",
				"ArnimaHealTurretTome",
				"ArnimaInfernalWatcherTome",
				"ArnimaRanger",
				"ArnimaRetributionTome",
				"ArnimaStorm",
				"arnimatomefear",
				"zzzCHMeridiaConjure"
			]
		},
        process: [{
			//Process REFR
			load: {
				signature: "REFR",
				overrides: false,
				filter: function(record) {
					let baseRecord = xelib.GetLinksTo(record, "NAME");
					if(!settings.processREFR) {
						return false;
					} else if(xelib.Name(xelib.GetElementFile(xelib.GetWinningOverride(record))) == "Poverty.esp") {
						return false;
					} else if(!"ALCH|AMMO|ARMO|BOOK|INGR|MISC|SLGM|WEAP".includes(xelib.Signature(baseRecord))) {
						return false;
					} else if(xelib.GetRecordFlag(record, "Initially Disabled")) {
						return false;
					} else if(isInList(locals.blacklistREFR, xelib.EditorID(record)) && !isInList(locals.whitelistREFR, xelib.EditorID(record))) {
						return false;
					} else if(isInList(locals.blacklist, xelib.EditorID(baseRecord)) && !isInList(locals.whitelist, xelib.EditorID(baseRecord))) {
						return false;
					} else {
						return true;
					}
				}
			},
			patch: function (record, helpers, settings, locals) {
				if(settings.logCurrent) {
					helpers.logMessage(xelib.LongName(record));
				}
				let baseRecord = xelib.GetWinningOverride(xelib.GetLinksTo(record, "NAME"));
				let editorID = xelib.EditorID(baseRecord);
				
				//Add poverty LVLI record
				let lvliRecord = AddPovertyLVLI(patchFile, baseRecord, editorID, "REFR", patchFile, locals, helpers);
				
				//Add XLIB to reference
				xelib.AddElementValue(record, "XLIB", xelib.EditorID(lvliRecord));
				
				//Change the name
				switch(xelib.Signature(baseRecord)) {
					case "ALCH":
						if(xelib.HasKeyword(baseRecord, "VendorItemPotion") || xelib.HasKeyword(baseRecord, "VendorItemPoison")) {
							xelib.SetValue(record, "NAME", "DummyDrink");
						} else if(xelib.HasElement(baseRecord, "ENIT\\Sound - Consume") && xelib.GetValue(baseRecord, "ENIT\\Sound - Consume") != "NULL - Null Reference [00000000]" && xelib.GetHexFormID(xelib.GetLinksTo(baseRecord, "ENIT\\Sound - Consume"), false, false) == "000B6435") {
							xelib.SetValue(record, "NAME", "DummyDrink");
						} else {
							xelib.SetValue(record, "NAME", "DummyFood");
						}
						break;
					case "AMMO":
						xelib.SetValue(record, "NAME", "DummyArrow");
						break;
					case "ARMO":
						if(xelib.HasKeyword(baseRecord, "ArmorBoots")) {
							xelib.SetValue(record, "NAME", "DummyBoots");
						} else if(xelib.HasKeyword(baseRecord, "ArmorCuirass")) {
							xelib.SetValue(record, "NAME", "DummyCuirass");
						} else if(xelib.HasKeyword(baseRecord, "ArmorGauntlets")) {
							xelib.SetValue(record, "NAME", "DummyGauntlets");
						} else if(xelib.HasKeyword(baseRecord, "ArmorHelmet")) {
							xelib.SetValue(record, "NAME", "DummyHelmet");
						} else if(xelib.HasKeyword(baseRecord, "ArmorShield")) {
							xelib.SetValue(record, "NAME", "DummyShield");
						} else if(xelib.HasKeyword(baseRecord, "ClothingCirclet")) {
							xelib.SetValue(record, "NAME", "DummyCirclet");
						} else if(xelib.HasKeyword(baseRecord, "ClothingRing")) {
							xelib.SetValue(record, "NAME", "DummyRing");
						} else if(xelib.HasKeyword(baseRecord, "ClothingNecklace")) {
							xelib.SetValue(record, "NAME", "DummyAmulet");
						} else if(xelib.HasKeyword(baseRecord, "ClothingFeet")) {
							xelib.SetValue(record, "NAME", "DummyBoots");
						} else if(xelib.HasKeyword(baseRecord, "ClothingBody")) {
							xelib.SetValue(record, "NAME", "DummyCuirass");
						} else if(xelib.HasKeyword(baseRecord, "ClothingHands")) {
							xelib.SetValue(record, "NAME", "DummyGauntlets");
						} else if(xelib.HasKeyword(baseRecord, "ClothingHead")) {
							xelib.SetValue(record, "NAME", "DummyHelmet");
						}
						break;
					case "BOOK":
						xelib.SetValue(record, "NAME", "DummyBook");
						break;
					case "INGR":
						xelib.SetValue(record, "NAME", "DummyIngredient");
						break;
					case "MISC":
						if(editorID.includes("Gold001")) {
							xelib.SetValue(record, "NAME", "DummySeptim");
						} else if(getsReferencedByRecordWithSignature(baseRecord, "COBJ", "")) {
							xelib.SetValue(record, "NAME", "DummyResource");
						} else {
							xelib.SetValue(record, "NAME", "DummyClutter");
						}
						break;
					case "SLGM":
						xelib.SetValue(record, "NAME", "DummySoulGem");
						break;
					case "WEAP":
						if(xelib.HasKeyword(baseRecord, "WeapTypeBattleaxe")) {
							xelib.SetValue(record, "NAME", "DummyBattleaxe");
						} else if(xelib.HasKeyword(baseRecord, "WeapTypeBow")) {
							xelib.SetValue(record, "NAME", "DummyBow");
						} else if(xelib.HasKeyword(baseRecord, "WeapTypeDagger")) {
							xelib.SetValue(record, "NAME", "DummyDagger");
						} else if(xelib.HasKeyword(baseRecord, "WeapTypeGreatsword")) {
							xelib.SetValue(record, "NAME", "DummyGreatSword");
						} else if(xelib.HasKeyword(baseRecord, "WeapTypeMace")) {
							xelib.SetValue(record, "NAME", "DummyMace");
						} else if(xelib.HasKeyword(baseRecord, "WeapTypeSword")) {
							xelib.SetValue(record, "NAME", "DummySword");
						} else if(xelib.HasKeyword(baseRecord, "WeapTypeWarAxe")) {
							xelib.SetValue(record, "NAME", "DummyWarAxe");
						} else if(xelib.HasKeyword(baseRecord, "WeapTypeWarhammer")) {
							xelib.SetValue(record, "NAME", "DummyWarhammer");
						} else if(xelib.HasKeyword(baseRecord, "WeapTypeStaff")) {
							xelib.SetValue(record, "NAME", "DummyStaff");
						}
						break;
				}
			}
		}, {
			//Process CONT
			load: {
				signature: "CONT",
				overrides: false,
				filter: function(record) {
					if(!settings.processCONT) {
						return false;
					} else if(xelib.Name(xelib.GetElementFile(xelib.GetWinningOverride(record))) == "Poverty.esp") {
						return false;
					} else if(!xelib.HasElement(record, "Items")) {
						return false;
					} else if(isInList(locals.blacklistCONT, xelib.EditorID(record)) && !isInList(locals.whitelistCONT, xelib.EditorID(record))) {
						return false;
					} else {
						return true;
					}
				}
			},
			patch: function (record, helpers, settings, locals) {
				if(settings.logCurrent) {
					helpers.logMessage(xelib.LongName(record));
				}
				
				//Get previous Record
				let masterRecord = xelib.GetMasterRecord(record);
				let overrides = xelib.GetOverrides(masterRecord);
				let previousRecord;
				if(overrides.length == 1) {
					previousRecord = masterRecord;
				} else {
					previousRecord = overrides[overrides.length - 2];
				}
				let previousFile = xelib.Name(xelib.GetElementFile(previousRecord));

				
				//Cycle through items
				for(let i = 0; i < xelib.ElementCount(xelib.GetElement(previousRecord, "Items")); i++) {
					let item = xelib.GetLinksTo(previousRecord, "Items\\[" + i.toString() + "]\\CNTO\\Item");
					let editorID = xelib.EditorID(item);
					//Replace items with poverty LVLI
					if((previousFile == settings.customPatch || "Smashed Patch.esp|Bashed Patch, 0.esp".includes(previousFile)) && xelib.Name(xelib.GetElementFile(item)) == "Poverty.esp") {
						xelib.RemoveItem(record, xelib.GetValue(item, "Record Header\\FormID"));
					} else if(!"LVLI|KEYM".includes(xelib.Signature(item)) && !(isInList(locals.blacklist, editorID) && !isInList(locals.whitelist, editorID))) {
						let lvliRecord = AddPovertyLVLI(patchFile, xelib.GetWinningOverride(item), xelib.EditorID(record), "CONT", patchFile, locals, helpers);
						xelib.AddItem(record, xelib.EditorID(lvliRecord), xelib.GetValue(previousRecord, "Items\\[" + i.toString() + "]\\CNTO\\Count"));
						xelib.RemoveItem(record, xelib.GetValue(item, "Record Header\\FormID"));
					}
				}
			}
		}, {
			//Process LVLI
			load: {
				signature: "LVLI",
				overrides: false,
				filter: function(record) {
					if(!settings.processLVLI) {
						return false;
					} else if(xelib.Name(xelib.GetElementFile(xelib.GetWinningOverride(record))) == "Poverty.esp") {
						return false;
					} else if(!xelib.HasElement(record, "Leveled List Entries")) {
						return false;
					} else if(isInList(locals.blacklistLVLI, xelib.EditorID(record)) && !isInList(locals.whitelistLVLI, xelib.EditorID(record))) {
						return false;
					} else if(getsReferencedByRecordWithSignature(record, "OTFT", "")) {
						return false;
					} else {
						return true;
					}
				}
			},
			patch: function (record, helpers, settings, locals) {
				if(settings.logCurrent) {
					helpers.logMessage(xelib.LongName(record));
				}
				let editorID = xelib.EditorID(record);
				
				//Get previous Record
				let masterRecord = xelib.GetMasterRecord(record);
				let overrides = xelib.GetOverrides(masterRecord);
				let previousRecord;
				if(overrides.length == 1) {
					previousRecord = masterRecord;
				} else {
					previousRecord = overrides[overrides.length - 2];
				}
				let previousFile = xelib.Name(xelib.GetElementFile(masterRecord));
				let getsReferencedByFloraRecord = getsReferencedByRecordWithSignature(masterRecord, "FLOR", "TREE");
				let onlyGetsUsedByNPCRecords = onlyGetsUsedByRecordWithSignature(masterRecord, "NPC_", "QUST", patchFile);

				//Cycle through leveled entries
				for(let i = 0; i < xelib.ElementCount(xelib.GetElement(previousRecord, "Leveled List Entries")); i++) {
					let leveledEntry = xelib.GetLinksTo(previousRecord, "Leveled List Entries\\[" + i.toString() + "]\\LVLO\\Reference");
					let signature = xelib.Signature(leveledEntry);
					let count = xelib.GetValue(previousRecord, "Leveled List Entries\\[" + i.toString() + "]\\LVLO\\Count");
					let level = xelib.GetValue(previousRecord, "Leveled List Entries\\[" + i.toString() + "]\\LVLO\\Level");
					//Replace leveled entry with poverty LVLI
					if((previousFile == settings.customPatch || "Smashed Patch.esp|Bashed Patch, 0.esp".includes(previousFile)) && xelib.Name(xelib.GetElementFile(leveledEntry)) == "Poverty.esp") {
						xelib.RemoveLeveledEntry(record, xelib.GetValue(leveledEntry, "Record Header\\FormID"));
					} else if((!"LVLI|KEYM|WEAP".includes(signature) || ("WEAP".includes(signature) && !onlyGetsUsedByNPCRecords) || ("AMMO".includes(signature) && count > 1)) && !(isInList(locals.blacklist, xelib.EditorID(leveledEntry)) && !isInList(locals.whitelist, xelib.EditorID(leveledEntry)))) {
						//Exchange the old leveled entry with a poverty variant
						let lvliRecord;
						if(getsReferencedByFloraRecord) {
							lvliRecord = AddPovertyLVLI(patchFile, xelib.GetWinningOverride(leveledEntry), editorID, "FLOR", patchFile, locals, helpers);
						} else if(onlyGetsUsedByNPCRecords && signature == "AMMO") {
							lvliRecord = AddPovertyLVLI(patchFile, xelib.GetWinningOverride(leveledEntry), editorID, "NPC_", patchFile, locals, helpers);
						} else {
							lvliRecord = AddPovertyLVLI(patchFile, xelib.GetWinningOverride(leveledEntry), editorID, "LVLI", patchFile, locals, helpers);
						}
						if(signature == "AMMO" && onlyGetsUsedByNPCRecords) {
							for(let j = 0; j < xelib.ElementCount(xelib.GetElement(record, "Leveled List Entries")); j++) {
								let currentCount = xelib.GetValue(previousRecord, "Leveled List Entries\\[" + j.toString() + "]\\LVLO\\Count");								
								if(xelib.EditorID(xelib.GetWinningOverride(xelib.GetLinksTo(record, "Leveled List Entries\\[" + j.toString() + "]\\LVLO\\Reference"))) == xelib.EditorID(leveledEntry) && currentCount == count && currentCount > 1) {
									xelib.SetValue(record, "Leveled List Entries\\[" + j.toString() + "]\\LVLO\\Count", "1");
									xelib.AddLeveledEntry(record, xelib.EditorID(lvliRecord), level, (count - 1).toString());
									break;
								}
							}
						} else {
							xelib.AddLeveledEntry(record, xelib.EditorID(lvliRecord), level, count);
							xelib.RemoveLeveledEntry(record, xelib.GetValue(leveledEntry, "Record Header\\FormID"));
						}
					}
				}
			}
		}, {
			//Process NPC_
			load: {
				signature: "NPC_",
				overrides: false,
				filter: function(record) {
					if(!settings.processNPC_) {
						return false;
					} else if(xelib.Name(xelib.GetElementFile(xelib.GetWinningOverride(record))) == "Poverty.esp") {
						return false;
					} else if(!xelib.HasElement(record, "Items")) {
						return false;
					} else if(isInList(locals.blacklistNPC, xelib.EditorID(record)) && !isInList(locals.whitelistNPC, xelib.EditorID(record))) {
						return false;
					} else {
						return true;
					}
				}
			},
			patch: function (record, helpers, settings, locals) {
				if(settings.logCurrent) {
					helpers.logMessage(xelib.LongName(record));
				}

				//Get previous Record
				let masterRecord = xelib.GetMasterRecord(record);
				let overrides = xelib.GetOverrides(masterRecord);
				let previousRecord;
				if(overrides.length == 1) {
					previousRecord = masterRecord;
				} else {
					previousRecord = overrides[overrides.length - 2];
				}
				let previousFile = xelib.Name(xelib.GetElementFile(previousRecord));

				//Cycle through items
				for(let i = 0; i < xelib.ElementCount(xelib.GetElement(previousRecord, "Items")); i++) {
					let item = xelib.GetLinksTo(previousRecord, "Items\\[" + i.toString() + "]\\CNTO\\Item");
					let editorID = xelib.EditorID(item);
					let signature = xelib.Signature(item);
					let count = xelib.GetValue(previousRecord, "Items\\[" + i.toString() + "]\\CNTO\\Count");
					//Replace items with poverty LVLI
					if((previousFile == settings.customPatch || "Smashed Patch.esp|Bashed Patch, 0.esp".includes(previousFile)) && xelib.Name(xelib.GetElementFile(item)) == "Poverty.esp") {
						xelib.RemoveItem(record, xelib.GetValue(item, "Record Header\\FormID"));
					} else if((!"LVLI|KEYM|WEAP|AMMO|ARMO".includes(signature) || ("AMMO|ARMO".includes(signature) && count > 1)) && !(isInList(locals.blacklist, editorID) && !isInList(locals.whitelist, editorID))) {
						let lvliRecord = AddPovertyLVLI(patchFile, xelib.GetWinningOverride(item), xelib.EditorID(record), "NPC_", patchFile, locals, helpers);
						if(signature == "AMMO") {
							for(let j = 0; j < xelib.ElementCount(xelib.GetElement(record, "Items")); j++) {
								let currentCount = xelib.GetValue(previousRecord, "Items\\[" + j.toString() + "]\\CNTO\\Count");
								if(xelib.EditorID(xelib.GetWinningOverride(xelib.GetLinksTo(record, "Items\\[" + j.toString() + "]\\CNTO\\Item"))) == xelib.EditorID(item) && currentCount == count && currentCount > 1) {
									xelib.SetValue(record, "Items\\[" + j.toString() + "]\\CNTO\\Count", "1");
									xelib.AddItem(record, xelib.EditorID(lvliRecord), (count - 1).toString());
									break;
								}
							}
						} else {
							xelib.AddItem(record, xelib.EditorID(lvliRecord), count);
							xelib.RemoveItem(record, xelib.GetValue(item, "Record Header\\FormID"));
						}
					}
				}
			}
		}, {
			//Process FLOR
			load: {
				signature: "FLOR",
				overrides: false,
				filter: function(record) {
					if(!settings.processFLORandTREE) {
						return false;
					} else if(xelib.Name(xelib.GetElementFile(xelib.GetWinningOverride(record))) == "Poverty.esp") {
						return false;
					} else if(!xelib.HasElement(record, "PFIG")) {
						return false;
					} else if(!"ALCH|AMMO|ARMO|BOOK|INGR|MISC|SLGM|WEAP".includes(xelib.Signature(xelib.GetLinksTo(record, "PFIG")))) {
						return false;
					} else if(isInList(locals.blacklistFLOR, xelib.EditorID(record)) && !isInList(locals.whitelistFLOR, xelib.EditorID(record))) {
						return false;
					} else {
						return true;
					}
				}
			},
			patch: function (record, helpers, settings, locals) {
				if(settings.logCurrent) {
					helpers.logMessage(xelib.LongName(record));
				}
				let ingredient = xelib.GetLinksTo(record, "PFIG");
				let editorID = xelib.EditorID(ingredient);
				let lvliRecord = AddPovertyLVLI(patchFile, xelib.GetWinningOverride(ingredient), xelib.EditorID(record), "FLOR", patchFile, locals, helpers);
				xelib.SetLinksTo(record, lvliRecord, "PFIG");
			}
		}, {
			//Process TREE
			load: {
				signature: "TREE",
				overrides: false,
				filter: function(record) {
					if(!settings.processFLORandTREE) {
						return false;
					} else if(xelib.Name(xelib.GetElementFile(xelib.GetWinningOverride(record))) == "Poverty.esp") {
						return false;
					} else if(!xelib.HasElement(record, "PFIG")) {
						return false;
					} else if(!"ALCH|AMMO|ARMO|BOOK|INGR|MISC|SLGM|WEAP".includes(xelib.Signature(xelib.GetLinksTo(record, "PFIG")))) {
						return false;
					} else if(isInList(locals.blacklistTREE, xelib.EditorID(record)) && !isInList(locals.whitelistTREE, xelib.EditorID(record))) {
						return false;
					} else {
						return true;
					}
				}
			},
			patch: function (record, helpers, settings, locals) {
				if(settings.logCurrent) {
					helpers.logMessage(xelib.LongName(record));
				}
				let ingredient = xelib.GetLinksTo(record, "PFIG");
				let editorID = xelib.EditorID(ingredient);
				let lvliRecord = AddPovertyLVLI(patchFile, xelib.GetWinningOverride(ingredient), xelib.EditorID(record), "TREE", patchFile, locals, helpers);
				xelib.SetLinksTo(record, lvliRecord, "PFIG");
			}
		}],
        finalize: function () {
        }
    })
});

function isInList(list, editorID) {
	let i;
	for(i = 0; i < list.length; i++) {
		if(editorID.substring(0, list[i].length) == list[i]) {
			return true;
		}
	}
	return false;
}

function onlyGetsUsedByRecordWithSignature(record, signature, signature2, patchFile) {
	let references = xelib.GetReferencedBy(record);
	count = references.length;
	let rightSignature = onlyGetsUsedByRecordWithSignatureRecursive(record, signature, signature2, patchFile);
	for(let i = 0; i < references.length; i++) {
		let reference = xelib.GetMasterRecord(references[i]);
		if(xelib.GetFileName(xelib.GetElementFile(xelib.GetMasterRecord(reference))) == xelib.GetFileName(patchFile)) {
			count--;
		}
	}

	if(rightSignature == count && count != 0) {
		return true;
	} else {
		return false;
	}
}

function onlyGetsUsedByRecordWithSignatureRecursive(record, signature, signature2, patchFile) {
	let references = xelib.GetReferencedBy(record);
	let rightSignature = 0;
	for(let i = 0; i < references.length; i++) {
		let reference = xelib.GetMasterRecord(references[i]);
		let currentSignature = xelib.Signature(reference);
		if(currentSignature == signature || currentSignature == signature2) {
			rightSignature++;
		}
		if(currentSignature == "LVLI" && onlyGetsUsedByRecordWithSignatureRecursive(reference, signature, signature2, patchFile)) {
			rightSignature++;
		}
	}
	return rightSignature;
}

function getsReferencedByRecordWithSignature(record, signature, signature2) {
	let references = xelib.GetReferencedBy(record);
	for(let i = 0; i < references.length; i++) {
		let currentSignature = xelib.Signature(references[i]);
		if(currentSignature == signature || currentSignature == signature2) {
			return true;
		}
	}
	return false;
}

function AddPovertyLVLI(file, record, originEditorID, originSignature, patchFile, locals, helpers) {
	let signature = xelib.Signature(record);
	let editorID = xelib.EditorID(record);
	//If reference is LVLI get the first non LVLI entry
	if(signature == "LVLI" && xelib.Signature(xelib.GetLinksTo(record, "Leveled List Entries\\[0]\\LVLO\\Reference")) == "LVLI" && xelib.HasElement(xelib.GetLinksTo(record, "Leveled List Entries\\[0]\\LVLO\\Reference"), "Leveled List Entries")) {
		var innerlvli = xelib.GetWinningOverride(xelib.GetLinksTo(record, "Leveled List Entries\\[0]\\LVLO\\Reference"));
		while(xelib.Signature(innerlvli) == "LVLI" && xelib.Signature(xelib.GetLinksTo(innerlvli, "Leveled List Entries\\[0]\\LVLO\\Reference")) == "LVLI" && xelib.HasElement(xelib.GetLinksTo(record, "Leveled List Entries\\[0]\\LVLO\\Reference"), "Leveled List Entries")) {
			innerlvli = xelib.GetWinningOverride(xelib.GetLinksTo(innerlvli, "Leveled List Entries\\[0]\\LVLO\\Reference"));
		}
		signature = xelib.Signature(innerlvli);
	}
	//Special cases
	if(originSignature == "FLOR" || originSignature == "TREE" || (originSignature == "LVLI" && isInList(locals.floraItems, originEditorID))) {
		editorID = editorID + "_FLORA";
	} else if(editorID.includes("Gold001") && (isInList(locals.merchantGold, originEditorID || originEditorID.includes("Vendor") || originEditorID.includes("Merchant")))) {
		editorID = editorID + "_MERCHANT";
	} else if(editorID.includes("SpellTome") || editorID.includes("Scroll") || isInList(locals.spellBook, editorID)) {
		editorID = editorID + "_SPELL";
	} else if((originSignature == "NPC_" && (signature == "AMMO" || isInList(locals.deadItemNPCs, originEditorID))) || (originSignature == "LVLI" && (("MISC" == signature && originEditorID.includes("DeathItem") && getsReferencedByRecordWithSignature(record, "COBJ", "")) || isInList(locals.npcItems, originEditorID) || ("ALCH|INGR".includes(signature) && originEditorID.includes("DeathItem"))))) {
		editorID = editorID + "_NPC";
	}

	if(!(xelib.HasElement(patchFile, "LVLI\\p" + editorID) || xelib.HasElement(xelib.FileByName("Poverty.esp"), "LVLI\\p" + editorID))) {
		//Add LVLI record
		let lvli = xelib.AddElement(file, "LVLI\\LVLI");
		xelib.AddElementValue(lvli, "EDID", "p" + editorID);
		xelib.SetFlag(lvli, "LVLF", "Calculate for each item in count", true);
		xelib.AddLeveledEntry(lvli, xelib.GetHexFormID(record, false, false), "1", "1");
		switch(signature) {
			case "ALCH":
				if(editorID.includes("_FLORA")) {
					xelib.AddElementValue(lvli, "LVLG", "pHarvestFoodFlora");
				} else if(editorID.includes("_NPC")) {
					xelib.AddElementValue(lvli, "LVLG", "pHarvestFoodNPC");
				} else if(xelib.HasKeyword(record, "VendorItemPotion") || xelib.HasKeyword(record, "VendorItemPoison")) {
					xelib.AddElementValue(lvli, "LVLG", "pPotion");
				} else if(xelib.HasElement(record, "ENIT\\Sound - Consume") && xelib.GetValue(record, "ENIT\\Sound - Consume") != "NULL - Null Reference [00000000]" && xelib.GetHexFormID(xelib.GetLinksTo(record, "ENIT\\Sound - Consume"), false, false) == "000B6435") {
					xelib.AddElementValue(lvli, "LVLG", "pDrink");
				} else {
					xelib.AddElementValue(lvli, "LVLG", "pFood");
				}
				break;
			case "AMMO":
				if(editorID.includes("_NPC")) {
					xelib.AddElementValue(lvli, "LVLG", "pAmmoNPC");
				} else {
					xelib.AddElementValue(lvli, "LVLG", "pAmmo");
				}
				break;
			case "ARMO":
				xelib.AddElementValue(lvli, "LVLG", "pArmor");
				break;
			case "BOOK":
				if(editorID.includes("_SPELL")) {
					xelib.AddElementValue(lvli, "LVLG", "pBookSpell");
				} else {
					xelib.AddElementValue(lvli, "LVLG", "pBook");
				}
				break;
			case "INGR":
				if(editorID.includes("_FLORA")) {
					xelib.AddElementValue(lvli, "LVLG", "pHarvestIngredientsFlora");
				} else if(editorID.includes("_NPC")) {
					xelib.AddElementValue(lvli, "LVLG", "pHarvestIngredientsNPC");
				} else {
					xelib.AddElementValue(lvli, "LVLG", "pIngredient");
				}
				break;
			case "MISC":
				if(editorID.includes("_NPC")) {
					xelib.AddElementValue(lvli, "LVLG", "pHarvestResourceNPC");
				} else if(editorID.includes("_MERCHANT")) {
					xelib.AddElementValue(lvli, "LVLG", "pMerchantGold");
				} else if(editorID.includes("Gold001")) {
					xelib.AddElementValue(lvli, "LVLG", "pGold");
				} else if(getsReferencedByRecordWithSignature(record, "COBJ", "")) {
					xelib.AddElementValue(lvli, "LVLG", "pResource");
				} else {
					xelib.AddElementValue(lvli, "LVLG", "pClutter");
				}
				break;
			case "SCRL":
				xelib.AddElementValue(lvli, "LVLG", "pBookSpell");
				break;
			case "SLGM":
				xelib.AddElementValue(lvli, "LVLG", "pSoulGem");
				break;
			case "WEAP":
				xelib.AddElementValue(lvli, "LVLG", "pWeapon");
				break;
		}
		return lvli;
	} else {
		if(xelib.HasElement(xelib.FileByName("Poverty.esp"), "LVLI\\p" + editorID)) {
			return xelib.GetElement(0, xelib.Path(xelib.FileByName("Poverty.esp")) + "\\LVLI\\p" + editorID);
		} else {
			return xelib.GetElement(0, xelib.Path(patchFile) + "\\LVLI\\p" + editorID);
		}
	}
}
