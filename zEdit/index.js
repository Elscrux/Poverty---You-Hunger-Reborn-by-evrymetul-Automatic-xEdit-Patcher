registerPatcher({
    info: info,
    gameModes: [xelib.gmTES5, xelib.gmSSE],
    settings: {
        label: 'Poverty Patcher',
        templateUrl: `${patcherUrl}/partials/settings.html`,
        defaultSettings: {
      		processREFR: true,
      		processCONT: true,
      		processFLORandTREE: true,
      		processLVLI: true,
      		processNPC_: true,
			logCurrent: true
        }
    },
    requiredFiles: ["Poverty.esp"],
	getFilesToPatch: function (filenames) {
		return filenames.filter(function(value, index, arr) {
            return (value != "Poverty.esp");
        });
    },
    execute: (patchFile, helpers, settings, locals) => ({
        initialize: function () {
			xelib.SetFileAuthor(patchFile, "evrymetul and Elscrux");
			xelib.SetFileDescription(patchFile, "All-in-One Patch for Poverty by evrymetul - Automatically generated by zEdit-Patcher by Elscrux");
			
			helpers.logMessage("Building references: This might take several minutes");
			xelib.BuildReferences(0, true);
			
			locals.blacklist = [
					"DefaultBookShelfBookMarker",
					"AleWhiterunQuest",
					"ArmorBoneCrown",
					"ArmorDragonPriestMaskWoodHelmet",
					"BasketCarry",
					"bp2garden",
					"bp2skoomanote",
					"bp2wanted1",
					"BYOHHouseGuide",
					"C04HagravenHead",
					"CasSecEntranceCrest",
					"CivilWarMapFlag01",
					"CR12TotemsOfHircine",
					"CWArrow",
					"CWDummy",
					"CWFort",
					"CWIABCBarbarians",
					"CWIDissolution",
					"CWIEdictBeinaarkhNew",
					"CWIEntryExamination",
					"CWIMagickaMeteor",
					"CWIMGBootsArchmage",
					"CWIMiddenBarracksJournal",
					"CWIMiddenTempleJournalNew",
					"CWINecromancersMoon",
					"CWINelothSergiusNote",
					"CWINiryaNote",
					"CWIOrbsOfWinterhold",
					"CWIRepresentingTime",
					"CWIRunsDoll",
					"CWISealBeinaarkhNew",
					"CWISkoomaBook",
					"CWISkyrimChart",
					"CWISoulsPraxography",
					"CWIStroti",
					"CWITeleportSpellTome",
					"CWITF",
					"CWIWRCanopicJarNew",
					"CWIXU",
					"DA01",
					"DA03RuefulAxe",
					"DA04",
					"DA06Volendrung",
					"DA07",
					"DA08EbonyBlade",
					"DA13Afflicted",
					"DA14SamNote",
					"DA14SanguineRose",
					"DA14Water",
					"DA16SkullofCorruption",
					"DA16Torpor",
					"DancersFlute",
					"DB003TovaLetter",
					"DB01AventusLetter",
					"DB05ElvenBow",
					"DB06Schedule",
					"DB07Journal",
					"DBArmorGlovesReward",
					"DBBladeOfWoeReward",
					"DBCiceroJournal",
					"DLC01DrawKnife",
					"DLC01DweSchematics",
					"DLC1ElderScrollBack",
					"DLC01SoulCairnReaperFragment",
					"DLC01TortureTool01",
					"DLC1BoneHawk",
					"DLC1Book3Valuable",
					"DLC1DarkfallPassageNote",
					"DLC1DawnguardRune",
					"DLC1dunRedwaterDenJournal",
					"DLC1FVBook02English",
					"DLC1IvoryCrown",
					"DLC1LD_Aetheri",
					"DLC1LD_Katria",
					"DLC1nVampireNightPowerNecklaceBats",
					"DLC1RecipeFrenzy1",
					"DLC1RuunvaldJournal",
					"DLC1SoulCairnRJPOI2Note",
					"DLC1SpellTomeConjure",
					"DLC1VQ07InitiatesEwer",
					"DLC1V",
					"DLC2Bl",
					"DLC2dunBloodskalNote01",
					"DLC2dunFahlbtharzDwarvenHelmet",
					"DLC2dunHaknirScimitar01",
					"DLC2dunKarstaagSkullItemNoName",
					"DLC2dunKolbjornBoots",
					"DLC2dunKolbjornGauntlets",
					"DLC2dunKolbjornHelm",
					"DLC2dunKolbjornMinersNote",
					"DLC2dunKolbjornSkull",
					"DLC2dunKolbjornRalisJournal",
					"DLC2dunKolbjornRing",
					"DLC2dunNchardakCube",
					"DLC2DweKagrumezControlGemInv01",
					"DLC2ExpSpiderExperimentJournal",
					"DLC2FrostmothLetter04",
					"DLC2Hork",
					"DLC2Hrodulf",
					"DLC2IldariJournal",
					"DLC2KagrumezFateBow01",
					"dlc2MerchNote",
					"DLC2POIUshaNote01",
					"DLC2RR",
					"DLC2TG",
					"DLC2TT2HeartStone",
					"DremoraRobesBlackPlayable",
					"Dummy",
					"dunAbandonedPrisonNote",
					"dunAlftandDwemerStudy01",
					"dunAlftandEndrastsJournal01",
					"dunAlftandJ",
					"dunAlftandManifestJournal01",
					"dunAn",
					"dunBloatedMan",
					"dunBrokenOarHargarJournal",
					"dunC",
					"dunD",
					"dunEmbershardTatteredJournal",
					"dunF",
					"dunG",
					"dunHa",
					"dunHuntersBow",
					"dunIlinaltasDeepAdventurerJournal",
					"dunIronbindLetter",
					"dunK",
					"dunLabyrinthian",
					"DunLabyrinthianSpellTomeEquilibrium",
					"dunLiarsRetreatLonghammer",
					"dunLost",
					"dunMarkarthWizard_LabJournal",
					"dunMarkarthWizardSpiderControlStaff",
					"dunMidden",
					"dunMistwatch",
					"dunMovarthsBoots",
					"dunMzinchaleft",
					"dunN",
					"dunOrotheimJournal",
					"dunP",
					"DunP",
					"DUNPOIDragonAttackNote",
					"dunR",
					"dunSaarthalStaffJyrikStaff",
					"dunSerpentsBluffNote",
					"dunShipwreck04TriusNote",
					"dunSilentMoonsLunarBook",
					"dunSteamcragCampNote",
					"dunT",
					"dunU",
					"dunV",
					"dunW",
					"dunYng",
					"DunYngolBarrowSteelPlateHelmet",
					"EnchArmorDraugrHelmetResistFire03",
					"EnchCircletWaterbreathing",
					"EnchDraugrGreatswordHonedFire03",
					"EnchSteelBattleaxeFierySouls",
					"Favor",
					"FF",
					"FirebrandWine",
					"Freeform",
					"FXdustDropMedWEP",
					"highGateRuinsScroll",
					"ImperialWarHorn",
					"IronSwordBrokenHandle",
					"IronWarAxeBroken",
					"Letter",
					"Markarth",
					"MG03Book",
					"MGRArniel04SoulGem",
					"MGRDestruction",
					"MGRitual02Book",
					"MGRKeening",
					"mjb_Book",
					"mjb_DarkwaterCrossingNote01",
					"mjb_DawnstarQ01Journal",
					"mjb_RoriksteadNote",
					"mjb_RoriksteadQ01Journal",
					"MQ103FarengarBook",
					"MQ105Note",
					"MQ106DragonParchment",
					"MQPaarthurnaxBook",
					"MS",
					"NN01SinderionsJournal",
					"POI",
					"sc_ArvakSkullUNIQUE",
					"SolitudeToryggWarHorn",
					"SpellTomeConjureDaedrothNew",
					"SpellTomeConjureScampNew",
					"SpellTomeTransmuteOreMineral",
					"SovRoastOx",
					"SteelBattleAxeBroken",
					"T0",
					"TG00MadesiRing",
					"TG01HaelgaStatue",
					"TG02BillofSale",
					"TG03SabjornLetter",
					"TG04",
					"TG05GallusJournalPre",
					"TG07Chillrend001",
					"TG07MercersPlans",
					"TG08SkeletonKey",
					"TGBook0NightingalesVolume",
					"TGCrown",
					"TGFenceCaravanSatchel",
					"TGLT",
					"TGTQ",
					"TGRFOValueItem",
					"TGRGeneralValueItem",
					"TGTQ03SolitudeLetter",
					"TrapDweBallistaBoltAmmo01",
					"Windhelm",
					"YsgramorsBladePiece07"
			]
			
			locals.blacklistCONT = [
				"CCF_AllClothing",
				"CWI_Container_All",
				"DEMO",
				"DLC01QA",
				"DLC02QA",
				"DLC2dunFrostmoonVendorChest",
				"DLC2MaximianPack",
				"e3DEMO",
				"E3Demo",
				"MQ101BarracksChest02",
				"MQ201ElenwenOfficeChest",
				"QA",
				"SkyHavenArmoryChest"
			]
			
			locals.blacklistFLOR = [
				"CoinPurse",
				"BYOHMead",
				"TGCoinPurse"
			]
			
			locals.blacklistLVLI = [
					"ArmorCompanionsSet",
					"ArmorElvenSet",
					"ArmorGlassSet",
					"ArmorHideSet",
					"ArmorImperialHeavyHelmets",
					"ArmorImperialHeavySet",
					"ArmorImperialLightSet",
					"ArmorImperialStuddedSet",
					"ArmorIronSet",
					"ArmorLeatherSet",
					"ArmorOrcSet",
					"ArmorReachHelmet",
					"ArmorScaledSet",
					"ArmorStormcloakBearSet",
					"ArmorStormcloakHelmets",
					"ArmorStormcloakSet",
					"ArmorStuddedSet",
					"BYOHHouseTestItems",
					"BYOHLItemInnRuralDrinkNewWines",
					"BYOHRelationshipAdoptionLItemChildrensClothes",
					"ClothesFarm",
					"CW01BPlayerHelpItems",
					"CWBearArmorPlayerReward",
					"CWCourierDocuments",
					"CWFinaleFactionLeaderSwordList",
					"CWPlayerUniform",
					"CWRankReward",
					"CWSoldierImperialGear",
					"CWSoldierSonsGear",
					"CWSoldierWoundedOutfit",
					"DA03AxeDeathItem",
					"DA09DawnbreakerList",
					"DA14RingDeathItem",
					"DA14StaffDeathItem",
					"DB02ShackKey",
					"DB08DeathBook",
					"DeathContainerList",
					"DeathItemDwarvenSphere",
					"DLC1DawnGuardHelmet75",
					"DLC1FalmerShamanWeapon",
					"DLC1LItemDaedric",
					"DLC1LItemDawnguard",
					"DLC1LItemDisguisedHunterInventory",
					"DLC1LItemFalmer",
					"DLC1LItemGargoyleMineralsRaw100",
					"DLC1LItemKeeper",
					"DLC1LitemStaffFalmer",
					"DLC1LItemStaffFalmer",
					"DLC1LItemVampireCuirass",
					"DLC1LItemWeaponDawnguardCrossbowLoot75Gated",
					"DLC1LItemWeaponFalmerShaman",
					"DLC1RV03HunterArmor",
					"DLC1RV05RemainsList",
					"DLC1SublistEnchCrossbow",
					"DLC1SublistEnchDwarvenCrossbow",
					"DLC1SublistEnchVampireRobes",
					"DLC1SublistKeeper",
					"DLC1SublistStaffDestructionFalmer",
					"DLC1WrathmanSummonedWeapon2H",
					"DLC2BlacksmithArmorExtra100",
					"DLC2BlankStaff",
					"DLC2Bonemold",
					"DLC2Chitin",
					"DLC2dunHaknirGhostLeveledList",
					"DLC2dunKolbjornLItemMinerClothes",
					"DLC2ExpSpiderAlbinoDeathItemButt",
					"DLC2LItemArmorBootsHeavy",
					"DLC2LItemArmorBootsLight",
					"DLC2LitemArmorBootsLight",
					"DLC2LItemArmorCuirassHeavy",
					"DLC2LItemArmorCuirassLight",
					"DLC2LItemArmorGauntletsHeavy",
					"DLC2LItemArmorGauntletsLight",
					"DLC2LItemArmorHelmetHeavy",
					"DLC2LItemArmorHelmetLight",
					"DLC2LItemArmorShieldHeavy",
					"DLC2LitemArmorShieldHeavy",
					"DLC2LItemArmorShieldLight",
					"DLC2LItemBook",
					"DLC2LItemDraugrHulkingShield67",
					"DLC2LItemDrink75",
					"DLC2LItemIldariRobesDestruction",
					"DLC2LItemIngredientFoodPrepared",
					"DLC2LItemIngredientsCommon",
					"DLC2LItemIngredientsRare",
					"DLC2LItemIngredientsUncommon",
					"DLC2LItemSpellTomes",
					"DLC2LItemSpellTOmes",
					"DLC2LitemSpellTomes",
					"DLC2LItemWeaponBattleAxe",
					"DLC2LItemWeaponBow",
					"DLC2LItemWeaponDagger",
					"DLC2LItemWeaponGreatSword",
					"DLC2LItemWeaponMace",
					"DLC2LItemWeaponSword",
					"DLC2LItemWeaponWarAxe",
					"DLC2LItemWeaponWarhammer",
					"DLC2LootRieklingSpears50",
					"DLC2MerilarRendasDeathItem",
					"DLC2MQ06Miraak",
					"DLC2NordicHeavyBoss",
					"DLC2NordicShield20",
					"DLC2OutfitSkaalHatChance50",
					"DLC2SpellBook",
					"DLC2Stalhrim",
					"DLC2SublistEnchArmor",
					"DLC2SublistEnchNordic",
					"DLC2SublistEnchStahlrim",
					"DLC2SublistEnchStalhrim",
					"dunHillgrundsTombRewardList",
					"dunLItemFolgunthurMikrulSword",
					"dunLItemFrostmereBlade",
					"dunLItemGeirmundSigdisBow",
					"dunMarkarthWizardMeleeSecurity",
					"dunSilentMoonsLItemEnch",
					"GuardGear",
					"HunterHatChance50_CCF",
					"LItemApothecaryRecipesCommon100",
					"LItemArmorBootsHeavy",
					"LItemArmorBootsLight",
					"LitemArmorBootsLight",
					"LItemArmorCuirassHeavy",
					"LItemArmorCuirassLight",
					"LItemArmorDwarven",
					"LItemArmorGauntletsHeavy",
					"LItemArmorGauntletsLight",
					"LItemArmorHelmetHeavy",
					"LItemArmorHelmetLight",
					"LItemArmorShieldHeavy",
					"LitemArmorShieldHeavy",
					"LItemArmorShieldLight",
					"LItemBandit",
					"LItemBlacksmithMinDagger",
					"LItemBook",
					"LItemClothesFarm",
					"LItemClothesRegular",
					"LItemClothesWork",
					"LItemDA13Armor",
					"LItemDawnguard",
					"LItemDLC2ClothesDarkElfBlue",
					"LItemDLC2ClothesDarkElfBrn",
					"LItemDLC2ClothesDarkElfRed",
					"LItemDragonPriestStaff100",
					"LItemDraugr",
					"LItemDwarvenOnly",
					"LItemEnchCirclet",
					"LItemEnchDaedricAny",
					"LItemEnchHoodMagickaRate_Black_CCF",
					"LItemEnchImperialSword",
					"LItemEnchNecklace",
					"LItemEnchNecromancerRobes",
					"LItemEnchOrcishBattleaxe",
					"LItemEnchRing",
					"LItemFalmerWeapon",
					"LItemFoodBlackBriarMead100",
					"LItemFoodChild",
					"LItemFoodHonningbrewMead100",
					"LItemFoodRaw",
					"LItemForsworn",
					"LItemGemEmpty",
					"LItemGems",
					"LItemGutterSaint",
					"LItemHoodsBlueWhite_CCF",
					"LItemHoodsRedOrange_CCF",
					"LItemHunterWeaponBow",
					"LItemIngotGold50",
					"LItemIngredientFoodPrepared",
					"LItemIngredientsCommon",
					"LItemIngredientsRare",
					"LItemIngredientsUncommon",
					"LItemIngredientUncommonSame75",
					"LItemIngredientsUnderground",
					"LItemIronOrSteel",
					"LItemJewelryCirclet",
					"LItemJewelryNecklace",
					"LItemJewelryRing",
					"LItemJewelryRingSmall",
					"LitemJunk",
					"LItemLockPick100",
					"LItemLootIMineralsProcessed",
					"LItemMaceForOrcs",
					"LItemMiscVendorGems100",
					"LItemMiscVendorSoulGemEmpty",
					"LItemMiscVendorSoulGemFull",
					"LItemMS09",
					"LItemNecromancerRobes",
					"LItemOrcStronghold",
					"LItemOre",
					"LItemPenitusWeapon1H",
					"LItemPoison",
					"LItemPotion",
					"LItemReligiousSymbols",
					"LItemRobes",
					"LItemScroll",
					"LItemSilverHandWeapon",
					"LItemSoldierImperial",
					"LItemSoldierSons",
					"LItemSoulGemEmpty",
					"LItemSoulGemFull",
					"LItemSpellTomes",
					"LitemSpellTomes",
					"LItemSpellTOmes",
					"LItemStaffAlteration",
					"LItemStaffConjuration",
					"LItemStaffDestruction00",
					"LItemStaffDestruction25",
					"LItemStaffDestruction50",
					"LItemStaffDestruction75",
					"LItemStaffIllusion",
					"LItemStaffRestoration",
					"LItemSummersetShadowsArmor",
					"LItemTGAmuletofArticulation",
					"LItemThalmorDagger",
					"LItemThalmorShield",
					"LItemVampire",
					"LItemVigilant",
					"LItemWarlock",
					"LITemWarlockRobes",
					"LItemWeaponBattleAxe",
					"LItemWeaponBow",
					"LItemWeaponDagger",
					"LItemWeaponDwarven",
					"LItemWeaponGreatSword",
					"LItemWeaponMace",
					"LItemWeaponNightingale",
					"LItemWeaponSailor",
					"LItemWeaponSword",
					"LItemWeaponWarAxe",
					"LItemWeaponWarhammer",
					"LItemWEBattlemage",
					"LItemWerewolf",
					"LItemwerewolfBossWarhammer",
					"LItemWESpellsword",
					"LItemWEThief",
					"LootBanditArmor100",
					"LootDwarvenCenturionSoulGem",
					"LootFalmerOre100",
					"LootGoldChangeUrns",
					"LootSabrecatBodyParts",
					"LootStaffsNecromancy100",
					"MG04RewardLVL",
					"MGR01ItemList",
					"MGR2",
					"MGRitual",
					"MQ203AkaviriKatana",
					"MQ304TsunBattleAxe",
					"MS09Reward",
					"OutfitList",
					"PenitusGear",
					"PrisonerPants50",
					"RegionalHunterBoots",
					"RegionalHunterClothes",
					"RegionalHunterGloves",
					"RegionalVigilantHood",
				        "SF_LootDaedraSkin25",
					"SublistArmor",
					"SublistEnch",
					"SublistENchDaedricWarAxeAbsorb",
					"SublistScaledCuirassVariants",
					"SublistSoulGem",
					"SublistThalmor",
					"SublistWeapon",
					"TG02MercLItem",
					"TG07Chillrend",
					"TGLvlItemNightingale",
					"TGPotionof",
					"TGRewardPotion",
					"TGTQ04DeathItem",
					"UDGPDLC1SublistEnchVampireRobesMagickaRate",
					"USKPVigilantsWeaponMace",
					"USLEEPStormfang",
					"USLEEPSublistEnchDaedricBattle",
					"VendorEorlundSkyforgeSteelSet",
					"WE17BanditOutfitList"
			]
			
			locals.blacklistNPC = [
					"CWBattleTullius",
					"CWFieldCOSons",
					"CWSiege",
					"DBTreasCorpseSkeleton",
					"dunBleakFallsCorpseBretonThomas",
					"dunHonningbrewRatGuy",
					"dunMarkarthWizard_Guard",
					"DLC1dunDarkfallTreasCorpse01",
					"DLC1HunterBaseIntroVigilant",
					"DLC1VQ01VigilantTolanCorpse",
					"DLC2dunFahlbtharzExplorerCorpse",
					"DLC2dunGyldenhulAdventurer",
					"DLC2EncHunterNordM",
					"DLC2KagrumezBanditBoss",
					"DLC2MerilarRendas",
					"DLC2PillarRRGuard",
					"DLC2RR",
					"DLC2ServosRendas",
					"DLC2WE05Wizard",
					"dunCGImperialSoldierArcherA04",
					"dunPOIVolcanicLuckyLorenze",
					"e3DemoArvel",
					"E3DemoTowerBanditMissile",
					"EncForsworn",
					"EncHunter",
					"EncVigilantOfStendarr",
					"GaiusMaro",
					"Golldir",
					"Jdatharr",
					"MQ206Gormlaith",
					"MQ304Froki",
					"MS03ChaletGuardExterior",
					"Player",
					"SummonGormlaith",
					"TG08BTreasCorpseThiefNordMaleOld",
					"TG09TreasCorpseAnders",
					"TreasCorpseVigilantOfStendarrMale",
					"Urwa",
					"WEAdventurerBrawler"
			]
        
			locals.blacklistREFR = [
				"CWDummy",
				"DA16AwakeBarrierGem",
				"DBMarkarthDagger",
				"Favor",
				"FestivalSpicedWineSpigotRef",
				"SiddgeirBlackBriarMeadREF",
				"YsoldaFavorItemREF"
			]
			
			locals.blacklistTREE = [
				"BYOHHouseFlora",
				"BYOHHouseIngrd",
				"DLC01AncestorsGladeTree"
			]
		
			locals.merchantGold = [
				"Merchant",
				"Vendor",
				"PerkInvestorStoreUpgrade",
				"PerkMasterTraderGold",
				"KRY_Variable01Gold",
				"KRY_Variable02Gold",
				"KRY_Variable03Gold"
			]
		},
        process: [{
			//Process REFR
			load: {
				signature: "REFR",
				overrides: false,
				filter: function(record) {
					let baseRecord = xelib.GetLinksTo(record, "NAME");
					if(!settings.processREFR) {
						return false;
					} else if(xelib.Name(xelib.GetElementFile(xelib.GetWinningOverride(record))) == "Poverty.esp") {
						return false;
					} else if(!hasPovertySignature(baseRecord)) {
						return false;
					} else if(!xelib.HasElement(record, "NAME")) {
						return false;
					} else if(xelib.GetRecordFlag(record, "Initially Disabled")) {
						return false;
					} else if(xelib.Signature(xelib.GetLinksTo(record, "NAME")) == "LVLI") {
						return false;
					} else if(isInBlacklist(locals.blacklistREFR, xelib.EditorID(record))) {
						return false;
					} else if(isInBlacklist(locals.blacklist, xelib.EditorID(baseRecord))) {
						return false;
					} else {
						return true;
					}
				}
			},
			patch: function (record, helpers, settings, locals) {
				if(settings.logCurrent) {
					helpers.logMessage(xelib.LongName(record));
				}
				let baseRecord = xelib.GetWinningOverride(xelib.GetLinksTo(record, "NAME"));
				let editorID = xelib.EditorID(baseRecord);
				
				//Add poverty LVLI record
				let lvliRecord = AddPovertyLVLI(patchFile, baseRecord, editorID, "REFR", patchFile, helpers);
				
				//Add XLIB to reference
				xelib.AddElementValue(record, "XLIB", xelib.EditorID(lvliRecord));
				
				//Change the name
				switch(xelib.Signature(baseRecord)) {
					case "ALCH":
						if(xelib.HasKeyword(record, "VendorItemPotion") || xelib.HasKeyword(record, "VendorItemPoison")) {
							xelib.SetValue(record, "NAME", "DummyDrink");
						} else if(xelib.HasElement(record, "ENIT\\Sound - Consume") && xelib.GetValue(record, "ENIT\\Sound - Consume") != "NULL - Null Reference [00000000]" && xelib.GetHexFormID(xelib.GetLinksTo(record, "ENIT\\Sound - Consume"), false, false) == "000B6435") {
							xelib.SetValue(record, "NAME", "DummyDrink");
						} else {
							xelib.SetValue(record, "NAME", "DummyFood");
						}
						break;
					case "AMMO":
						xelib.SetValue(record, "NAME", "DummyArrow");
						break;
					case "ARMO":
						if(xelib.HasKeyword(baseRecord, "ArmorBoots")) {
							xelib.SetValue(record, "NAME", "DummyBoots");
						} else if(xelib.HasKeyword(baseRecord, "ArmorCuirass")) {
							xelib.SetValue(record, "NAME", "DummyCuirass");
						} else if(xelib.HasKeyword(baseRecord, "ArmorGauntlets")) {
							xelib.SetValue(record, "NAME", "DummyGauntlets");
						} else if(xelib.HasKeyword(baseRecord, "ArmorHelmet")) {
							xelib.SetValue(record, "NAME", "DummyHelmet");
						} else if(xelib.HasKeyword(baseRecord, "ArmorShield")) {
							xelib.SetValue(record, "NAME", "DummyShield");
						} else if(xelib.HasKeyword(baseRecord, "ClothingCirclet")) {
							xelib.SetValue(record, "NAME", "DummyCirclet");
						} else if(xelib.HasKeyword(baseRecord, "ClothingRing")) {
							xelib.SetValue(record, "NAME", "DummyRing");
						} else if(xelib.HasKeyword(baseRecord, "ClothingNecklace")) {
							xelib.SetValue(record, "NAME", "DummyAmulet");
						} else if(xelib.HasKeyword(baseRecord, "ClothingFeet")) {
							xelib.SetValue(record, "NAME", "DummyBoots");
						} else if(xelib.HasKeyword(baseRecord, "ClothingBody")) {
							xelib.SetValue(record, "NAME", "DummyCuirass");
						} else if(xelib.HasKeyword(baseRecord, "ClothingHands")) {
							xelib.SetValue(record, "NAME", "DummyGauntlets");
						} else if(xelib.HasKeyword(baseRecord, "ClothingHead")) {
							xelib.SetValue(record, "NAME", "DummyHelmet");
						}
						break;
					case "BOOK":
						xelib.SetValue(record, "NAME", "DummyBook");
						break;
					case "INGR":
						xelib.SetValue(record, "NAME", "DummyIngredient");
						break;
					case "MISC":
						if(editorID.includes("Gold001")) {
							xelib.SetValue(record, "NAME", "DummySeptim");
						} else if(getsReferencedByRecordWithSignature(baseRecord, "COBJ", "")) {
							xelib.SetValue(record, "NAME", "DummyResource");
						} else {
							xelib.SetValue(record, "NAME", "DummyClutter");
						}
						break;
					case "SLGM":
						xelib.SetValue(record, "NAME", "DummySoulGem");
						break;
					case "WEAP":
						if(xelib.HasKeyword(baseRecord, "WeapTypeBattleaxe")) {
							xelib.SetValue(record, "NAME", "DummyBattleaxe");
						} else if(xelib.HasKeyword(baseRecord, "WeapTypeBow")) {
							xelib.SetValue(record, "NAME", "DummyBow");
						} else if(xelib.HasKeyword(baseRecord, "WeapTypeDagger")) {
							xelib.SetValue(record, "NAME", "DummyDagger");
						} else if(xelib.HasKeyword(baseRecord, "WeapTypeGreatsword")) {
							xelib.SetValue(record, "NAME", "DummyGreatSword");
						} else if(xelib.HasKeyword(baseRecord, "WeapTypeMace")) {
							xelib.SetValue(record, "NAME", "DummyMace");
						} else if(xelib.HasKeyword(baseRecord, "WeapTypeSword")) {
							xelib.SetValue(record, "NAME", "DummySword");
						} else if(xelib.HasKeyword(baseRecord, "WeapTypeWarAxe")) {
							xelib.SetValue(record, "NAME", "DummyWarAxe");
						} else if(xelib.HasKeyword(baseRecord, "WeapTypeWarhammer")) {
							xelib.SetValue(record, "NAME", "DummyWarhammer");
						} else if(xelib.HasKeyword(baseRecord, "WeapTypeStaff")) {
							xelib.SetValue(record, "NAME", "DummyStaff");
						}
						break;
				}
			}
		}, {
			//Process CONT
			load: {
				signature: "CONT",
				overrides: false,
				filter: function(record) {
					if(!settings.processCONT) {
						return false;
					} else if(xelib.Name(xelib.GetElementFile(xelib.GetWinningOverride(record))) == "Poverty.esp") {
						return false;
					} else if(!xelib.HasElement(record, "Items")) {
						return false;
					} else if(isInBlacklist(locals.blacklistCONT, xelib.EditorID(record))) {
						return false;
					} else {
						return true;
					}
				}
			},
			patch: function (record, helpers, settings, locals) {
				if(settings.logCurrent) {
					helpers.logMessage(xelib.LongName(record));
				}
				
				//Get previous Record
				let masterRecord = xelib.GetMasterRecord(record);
				let overrides = xelib.GetOverrides(masterRecord);
				let previousRecord;
				if(overrides.length == 1) {
					previousRecord = masterRecord;
				} else {
					previousRecord = overrides[overrides.length - 2];
				}
				
				//Cycle through items
				for(let i = 0; i < xelib.GetValue(record, "COCT"); i++) {
					let item = xelib.GetLinksTo(previousRecord, "Items\\[" + i.toString() + "]\\CNTO\\Item");
					let editorID = xelib.EditorID(item);
					//Replace items with poverty LVLI
					if(!(("LVLI|KEYM".includes(xelib.Signature(item))) || isInBlacklist(locals.blacklist, editorID))) {
						let lvliRecord = AddPovertyLVLI(patchFile, xelib.GetWinningOverride(item), xelib.EditorID(record), "CONT", patchFile, helpers);
						xelib.AddItem(record, xelib.EditorID(lvliRecord), xelib.GetValue(previousRecord, "Items\\[" + i.toString() + "]\\CNTO\\Count"));
						xelib.RemoveItem(record, xelib.GetValue(item, "Record Header\\FormID"));
					}
				}
			}
		}, {
			//Process LVLI
			load: {
				signature: "LVLI",
				overrides: false,
				filter: function(record) {
					let masterRecord = xelib.GetMasterRecord(record);
					let overrides = xelib.GetOverrides(masterRecord);
					if(!settings.processLVLI) {
						return false;
					} else if(xelib.Name(xelib.GetElementFile(xelib.GetWinningOverride(record))) == "Poverty.esp") {
						return false;
					} else if(!xelib.HasElement(record, "Leveled List Entries")) {
						return false;
					} else if(isInBlacklist(locals.blacklistLVLI, xelib.EditorID(record))) {
						return false;
					} else if(getsReferencedByRecordWithSignature(record, "OTFT", "")) {
						return false;
					} else {
						return true;
					}
				}
			},
			patch: function (record, helpers, settings, locals) {
				if(settings.logCurrent) {
					helpers.logMessage(xelib.LongName(record));
				}
				
				//Get previous Record
				let masterRecord = xelib.GetMasterRecord(record);
				let overrides = xelib.GetOverrides(masterRecord);
				let previousRecord;
				if(overrides.length == 1) {
					previousRecord = masterRecord;
				} else {
					previousRecord = overrides[overrides.length - 2];
				}
				
				let getsReferencedByFloraRecord = getsReferencedByRecordWithSignature(previousRecord, "FLOR", "TREE");
				
				//Utility variables for setting the global
				let firstGlobal = "";
				let sameGlobalCount = 0;
				
				//Cycle through leveled entries
				for(let i = 0; i < xelib.GetValue(record, "LLCT"); i++) {
					let leveledEntry = xelib.GetLinksTo(previousRecord, "Leveled List Entries\\[" + i.toString() + "]\\LVLO\\Reference");
					let editorID = xelib.EditorID(leveledEntry);
					let signature = xelib.Signature(leveledEntry);
					
					//Replace leveled entry with poverty LVLI
					if(!(("LVLI|KEYM".includes(signature)) || isInBlacklist(locals.blacklist, editorID))) {
						//Exchange the old leveled entry with a poverty variant
						let lvliRecord;
						if(getsReferencedByFloraRecord) {
							lvliRecord = AddPovertyLVLI(patchFile, xelib.GetWinningOverride(leveledEntry), xelib.EditorID(record), "FLOR", patchFile, helpers);
						} else {
							lvliRecord = AddPovertyLVLI(patchFile, xelib.GetWinningOverride(leveledEntry), xelib.EditorID(record), "LVLI", patchFile, helpers);
						}
						xelib.AddLeveledEntry(record, xelib.EditorID(lvliRecord), "1", xelib.GetValue(previousRecord, "Leveled List Entries\\[" + i.toString() + "]\\LVLO\\Count"));
						xelib.RemoveLeveledEntry(record, xelib.GetValue(leveledEntry, "Record Header\\FormID"));
						if(i == 0){
							firstGlobal = xelib.GetValue(lvliRecord, "LVLG");
						}
						if(xelib.GetValue(lvliRecord, "LVLG") == firstGlobal) {
							sameGlobalCount++;
						}
					}
				}
				
				//Add global
				if(!xelib.HasElement(record, "LVLG") == sameGlobalCount ==  xelib.GetValue(record, "LLCT") && xelib.GetValue(record, "LVLD") == "1") {
					xelib.AddElementValue(record, "LVLG", firstGlobal);
				}
			}
		}, {
			//Process NPC_
			load: {
				signature: "NPC_",
				overrides: false,
				filter: function(record) {
					if(!settings.processNPC_) {
						return false;
					} else if(xelib.Name(xelib.GetElementFile(xelib.GetWinningOverride(record))) == "Poverty.esp") {
						return false;
					} else if(!xelib.HasElement(record, "Items")) {
						return false;
					} else if(isInBlacklist(locals.blacklistNPC, xelib.EditorID(record))) {
						return false;
					} else {
						return true;
					}
				}
			},
			patch: function (record, helpers, settings, locals) {
				if(settings.logCurrent) {
					//helpers.logMessage(xelib.LongName(record));
				}
				
				//Get previous Record
				let masterRecord = xelib.GetMasterRecord(record);
				let overrides = xelib.GetOverrides(masterRecord);
				let previousRecord;
				if(overrides.length == 1) {
					previousRecord = masterRecord;
				} else {
					previousRecord = overrides[overrides.length - 2];
				}
				
				//Cycle through items
				for(let i = 0; i < xelib.GetValue(record, "COCT"); i++) {
					let item = xelib.GetLinksTo(previousRecord, "Items\\[" + i.toString() + "]\\CNTO\\Item");
					let editorID = xelib.EditorID(item);
					let signature = xelib.Signature(item);
					
					//Replace items with poverty LVLI
					if(!("LVLI|KEYM|WEAP".includes(signature) || (("AMMO|ARMO".includes(signature)) && (xelib.GetValue(record, "Items\\[" + i.toString() + "]\\CNTO\\Count") == "1")) || isInBlacklist(locals.blacklist, editorID))) {
						helpers.logMessage(xelib.LongName(record));
						let lvliRecord = AddPovertyLVLI(patchFile, xelib.GetWinningOverride(item), xelib.EditorID(record), "NPC_", patchFile, helpers);
						if(signature != "AMMO") {
							xelib.AddItem(record, xelib.EditorID(lvliRecord), xelib.GetValue(previousRecord, "Items\\[" + i.toString() + "]\\CNTO\\Count"));
							xelib.RemoveItem(record, xelib.GetValue(item, "Record Header\\FormID"));
						} else {
							xelib.AddItem(record, xelib.EditorID(lvliRecord), (xelib.GetValue(previousRecord, "Items\\[" + i.toString() + "]\\CNTO\\Count") - 1).toString());
							for(let j = 0; j < xelib.GetValue(record, "COCT"); j++) {
								let item = xelib.GetLinksTo(previousRecord, "Items\\[" + j.toString() + "]\\CNTO\\Item");
								if(xelib.EditorID(item) == editorID) {
									xelib.SetValue(record, "Items\\[" + j.toString() + "]\\CNTO\\Count", "1");
									return;
								}
							}
						}
					}
				}
			}
		}, {
			//Process FLOR
			load: {
				signature: "FLOR",
				overrides: false,
				filter: function(record) {
					if(!settings.processFLORandTREE) {
						return false;
					} else if(xelib.Name(xelib.GetElementFile(xelib.GetWinningOverride(record))) == "Poverty.esp") {
						return false;
					} else if(!xelib.HasElement(record, "PFIG")) {
						return false;
					} else if(!hasPovertySignature(xelib.GetLinksTo(record, "PFIG"))) {
						return false;
					} else if(isInBlacklist(locals.blacklistFLOR, xelib.EditorID(record))) {
						return false;
					} else {
						return true;
					}
				}
			},
			patch: function (record, helpers, settings, locals) {
				if(settings.logCurrent) {
					helpers.logMessage(xelib.LongName(record));
				}
				let ingredient = xelib.GetLinksTo(record, "PFIG");
				let editorID = xelib.EditorID(ingredient);
				let lvliRecord = AddPovertyLVLI(patchFile, xelib.GetWinningOverride(ingredient), xelib.EditorID(record), "FLOR", patchFile, helpers);
				xelib.SetLinksTo(record, lvliRecord, "PFIG");
			}
		}, {
			//Process TREE
			load: {
				signature: "TREE",
				overrides: false,
				filter: function(record) {
					if(!settings.processFLORandTREE) {
						return false;
					} else if(xelib.Name(xelib.GetElementFile(xelib.GetWinningOverride(record))) == "Poverty.esp") {
						return false;
					} else if(!xelib.HasElement(record, "PFIG")) {
						return false;
					} else if(!hasPovertySignature(xelib.GetLinksTo(record, "PFIG"))) {
						return false;
					} else if(isInBlacklist(locals.blacklistTREE, xelib.EditorID(record))) {
						return false;
					} else {
						return true;
					}
				}
			},
			patch: function (record, helpers, settings, locals) {
				if(settings.logCurrent) {
					helpers.logMessage(xelib.LongName(record));
				}
				let ingredient = xelib.GetLinksTo(record, "PFIG");
				let editorID = xelib.EditorID(ingredient);
				let lvliRecord = AddPovertyLVLI(patchFile, xelib.GetWinningOverride(ingredient), xelib.EditorID(record), "TREE", patchFile, helpers);
				xelib.SetLinksTo(record, lvliRecord, "PFIG");
			}
		}],
        finalize: function () {
        }
    })
});

function isInBlacklist(blacklist, editorID) {
	let i;
	for(i = 0; i < blacklist.length; i++) {
		if(editorID.substring(0, blacklist[i].length) == blacklist[i]) {
			return true;
		}
	}
	return false;
}

function getsReferencedByRecordWithSignature(record, signature, signature2) {
	let references = xelib.GetReferencedBy(record);
	for(let i = 0; i < references.length; i++) {
		let currentSignature = xelib.Signature(references[i]);
		if(currentSignature == signature || currentSignature == signature2) {
			return true;
		}
	}
	return false;
}

function hasPovertySignature(record) {
	if("ALCH|AMMO|ARMO|BOOK|INGR|MISC|SLGM|WEAP".includes(xelib.Signature(record))) {
		return true;
	} else {
		return false;
	}
}

function AddPovertyLVLI(file, record, originEditorID, originSignature, patchFile, helpers) {
	let signature = xelib.Signature(record);
	let editorID = xelib.EditorID(record);
	//If reference is LVLI get the first non LVLI entry
	if(signature == "LVLI" && xelib.Signature(xelib.GetLinksTo(record, "Leveled List Entries\\[0]\\LVLO\\Reference")) == "LVLI" && xelib.HasElement(xelib.GetLinksTo(record, "Leveled List Entries\\[0]\\LVLO\\Reference"), "Leveled List Entries")) {
		var innerlvli = xelib.GetWinningOverride(xelib.GetLinksTo(record, "Leveled List Entries\\[0]\\LVLO\\Reference"));
		while(xelib.Signature(innerlvli) == "LVLI" && xelib.Signature(xelib.GetLinksTo(innerlvli, "Leveled List Entries\\[0]\\LVLO\\Reference")) == "LVLI" && xelib.HasElement(xelib.GetLinksTo(record, "Leveled List Entries\\[0]\\LVLO\\Reference"), "Leveled List Entries")) {
			innerlvli = xelib.GetWinningOverride(xelib.GetLinksTo(innerlvli, "Leveled List Entries\\[0]\\LVLO\\Reference"));
		}
		signature = xelib.Signature(innerlvli);
	}
	//Special cases
	if(originSignature == "FLOR" || originSignature == "TREE" || (originSignature == "LVLI" && originEditorID.includes("YASH2_Ingredient"))) {
		editorID = editorID + "_FLORA";
	} else if(editorID.includes("Gold001") && isInBlacklist(locals.merchantGold, originEditorID)) {
		editorID = editorID + "_MERCHANT";
	} else if(editorID.includes("SpellTome") || editorID.includes("Scroll")) {
		editorID = editorID + "_SPELL";
	} else if((originSignature == "NPC_" && "AMMO" == signature) || (originSignature == "LVLI" && ("MISC" == signature && originEditorID.includes("DeathItem") && getsReferencedByRecordWithSignature(record, "COBJ", "")) || ("ALCH|INGR".includes(signature) && originEditorID.includes("DeathItem")))) {
		editorID = editorID + "_NPC";
	}
	if(!(xelib.HasElement(patchFile, "LVLI\\p" + editorID) || xelib.HasElement(xelib.FileByName("Poverty.esp"), "LVLI\\p" + editorID))) {
		//Add LVLI record	
		let lvli = xelib.AddElement(file, "LVLI\\LVLI");
		xelib.AddElementValue(lvli, "EDID", "p" + editorID);
		xelib.SetFlag(lvli, "LVLF", "Calculate for each item in count", true);
		xelib.AddLeveledEntry(lvli, xelib.GetHexFormID(record, false, false), "1", "1");
		switch(signature) {
			case "ALCH":
				if(editorID.includes("_FLORA")) {
					xelib.AddElementValue(lvli, "LVLG", "pHarvestFoodFlora");
				} else if(editorID.includes("_NPC")) {
					xelib.AddElementValue(lvli, "LVLG", "pHarvestFoodNPC");
				} else if(xelib.HasKeyword(record, "VendorItemPotion") || xelib.HasKeyword(record, "VendorItemPoison")) {
					xelib.AddElementValue(lvli, "LVLG", "pPotion");
				} else if(xelib.HasElement(record, "ENIT\\Sound - Consume") && xelib.GetValue(record, "ENIT\\Sound - Consume") != "NULL - Null Reference [00000000]" && xelib.GetHexFormID(xelib.GetLinksTo(record, "ENIT\\Sound - Consume"), false, false) == "000B6435") {
					xelib.AddElementValue(lvli, "LVLG", "pDrink");
				} else {
					xelib.AddElementValue(lvli, "LVLG", "pFood");
				}
				break;
			case "AMMO":
				if(editorID.includes("_NPC")) {
					xelib.AddElementValue(lvli, "LVLG", "pAmmoNPC");
				} else {
					xelib.AddElementValue(lvli, "LVLG", "pAmmo");
				}
				break;
			case "ARMO":
				xelib.AddElementValue(lvli, "LVLG", "pArmor");
				break;
			case "BOOK":
				if(editorID.includes("_SPELL")) {
					xelib.AddElementValue(lvli, "LVLG", "pBookSpell");
				} else {
					xelib.AddElementValue(lvli, "LVLG", "pBook");
				}
				break;
			case "INGR":
				if(editorID.includes("_FLORA")) {
					xelib.AddElementValue(lvli, "LVLG", "pHarvestIngredientsFlora");
				} else if(editorID.includes("_NPC")) {
					xelib.AddElementValue(lvli, "LVLG", "pHarvestIngredientsNPC");
				} else {
					xelib.AddElementValue(lvli, "LVLG", "pIngredient");
				}
				break;
			case "MISC":
				if(editorID.includes("_NPC")) {
					xelib.AddElementValue(lvli, "LVLG", "pHarvestResourceNPC");
				} else if(editorID.includes("_MERCHANT")) {
					xelib.AddElementValue(lvli, "LVLG", "pMerchantGold");
				} else if(editorID.includes("Gold001")) {
					xelib.AddElementValue(lvli, "LVLG", "pGold");
				} else if(getsReferencedByRecordWithSignature(record, "COBJ", "")) {
					xelib.AddElementValue(lvli, "LVLG", "pResource");
				} else {
					xelib.AddElementValue(lvli, "LVLG", "pClutter");
				}
				break;
			case "SCRL":
				xelib.AddElementValue(lvli, "LVLG", "pBookSpell");
				break;
			case "SLGM":
				xelib.AddElementValue(lvli, "LVLG", "pSoulGem");
				break;
			case "WEAP":
				xelib.AddElementValue(lvli, "LVLG", "pWeapon");
				break;
		}
		return lvli;
	} else {
		if(xelib.HasElement(xelib.FileByName("Poverty.esp"), "LVLI\\p" + editorID)) {
			return xelib.GetElement(0, xelib.Path(xelib.FileByName("Poverty.esp")) + "\\LVLI\\p" + editorID);
		} else {
			return xelib.GetElement(0, xelib.Path(patchFile) + "\\LVLI\\p" + editorID);
		}
	}
}
